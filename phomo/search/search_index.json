{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":"<p>Python package and CLI utility to create photo mosaics.</p> <p> </p>"},{"location":"#overview","title":"Overview","text":"<p><code>phomo</code> lets you quickly and easily create photographic mosaics.</p>"},{"location":"#features","title":"Features","text":"<ul> <li>Simple: CLI interface to create photo mosaics in seconds.</li> <li>Configurable: Python package to create custom mosaics with ease.</li> <li>Fast: GPU acceleration for large mosaics.</li> </ul>"},{"location":"#installation","title":"Installation","text":"<p><code>phomo</code> requires python 3.9 or later. It can be installed with or without GPU acceleration.</p> <p>GPU acceleration</p> <p>For GPU acceleration you'll need a CUDA compatible GPU and the CUDA toolkit installed. See numba docs for details.</p>"},{"location":"#cli","title":"CLI","text":"<p>If you only need the command line interface, you can use <code>pipx</code>. It installs the <code>phomo</code> package in an isolated environment and makes it easy to uninstall.</p> <pre><code>pipx install 'phomo'\n# or for gpu acceleration\npipx install 'phomo[cuda]'\n</code></pre>"},{"location":"#python-package","title":"Python package","text":"<p>To install the Python package, use <code>pip</code>. It will install the CLI as well. It is recommended to use a virtual environment to not mess with your system packages.</p> <pre><code>pip install 'phomo'\n# or for gpu acceleration\npip install 'phomo[cuda]'\n</code></pre>"},{"location":"reference/SUMMARY/","title":"SUMMARY","text":"<ul> <li>phomo<ul> <li>grid</li> <li>master</li> <li>metrics</li> <li>mosaic</li> <li>palette</li> <li>pool</li> <li>utils</li> </ul> </li> </ul>"},{"location":"reference/__init__/","title":"init","text":""},{"location":"reference/__init__/#phomo.Master","title":"<code>Master</code>","text":"<p>               Bases: <code>Palette</code></p> Source code in <code>phomo/master.py</code> <pre><code>class Master(Palette):\n    @classmethod\n    def from_file(\n        cls,\n        master_image_file: PathLike,\n        crop_ratio: Optional[float] = None,\n        img_size: Optional[Tuple[int, int]] = None,\n        mode: Optional[str] = None,\n    ) -&gt; \"Master\":\n        \"\"\"Create a master image from file.\n\n        Args:\n            master_image_file: path to image file.\n            crop_ratio: width to height ratio to crop the master image to. 1 results in a square image.\n            img_size: resize the image to the provided size, width followed by height.\n            mode: convert the image to the provided mode. See PIL Modes.\n\n        Returns:\n            Master image instance.\n\n        Examples:\n            For black and white square 1280x1280 image.\n\n            &gt;&gt;&gt; Master.from_file(\"master.png\", crop_ratio=1, img_size=(1280, 1280), convert=\"L\")\n        \"\"\"\n        img = open_img_file(\n            master_image_file, crop_ratio=crop_ratio, size=img_size, mode=mode\n        )\n        return cls.from_image(img)\n\n    @classmethod\n    def from_image(cls, master_image: Image.Image) -&gt; \"Master\":\n        \"\"\"Create a master image from PIL.Image.Image\n\n        Args:\n            master_image: `PIL.Image` instance.\n\n        Returns:\n            Master image instance.\n        \"\"\"\n        array = np.asarray(master_image)\n        # make sure the arrays have 3 channels even in black and white\n        if array.ndim == 2:\n            array = np.stack([array] * 3, -1)\n        return cls(array)\n\n    def __init__(self, array: np.ndarray) -&gt; None:\n        \"\"\"The master image.\n\n        Args:\n            array: numpy array of the image, should contain 3 channels.\n\n        Returns:\n            Master image instance.\n        \"\"\"\n        super().__init__(array)\n\n    @property\n    def img(self):\n        \"\"\"`PIL.Image` of the master image.\"\"\"\n        return Image.fromarray(self.array.round(0).astype(\"uint8\"), mode=\"RGB\")\n\n    @property\n    def pixels(self) -&gt; np.ndarray:\n        \"\"\"Array containing the 3-channel pixel values of the master image.\"\"\"\n        return self.array.reshape(-1, self.array.shape[-1])\n\n    def __repr__(self) -&gt; str:\n        return f\"\"\"{self.__class__.__module__}.{self.__class__.__name__} at {hex(id(self))}:\n    shape: {self.array.shape}\"\"\"\n</code></pre>"},{"location":"reference/__init__/#phomo.Master.img","title":"<code>img</code>  <code>property</code>","text":"<p><code>PIL.Image</code> of the master image.</p>"},{"location":"reference/__init__/#phomo.Master.pixels","title":"<code>pixels: np.ndarray</code>  <code>property</code>","text":"<p>Array containing the 3-channel pixel values of the master image.</p>"},{"location":"reference/__init__/#phomo.Master.__init__","title":"<code>__init__(array)</code>","text":"<p>The master image.</p> <p>Parameters:</p> Name Type Description Default <code>array</code> <code>ndarray</code> <p>numpy array of the image, should contain 3 channels.</p> required <p>Returns:</p> Type Description <code>None</code> <p>Master image instance.</p> Source code in <code>phomo/master.py</code> <pre><code>def __init__(self, array: np.ndarray) -&gt; None:\n    \"\"\"The master image.\n\n    Args:\n        array: numpy array of the image, should contain 3 channels.\n\n    Returns:\n        Master image instance.\n    \"\"\"\n    super().__init__(array)\n</code></pre>"},{"location":"reference/__init__/#phomo.Master.from_file","title":"<code>from_file(master_image_file, crop_ratio=None, img_size=None, mode=None)</code>  <code>classmethod</code>","text":"<p>Create a master image from file.</p> <p>Parameters:</p> Name Type Description Default <code>master_image_file</code> <code>PathLike</code> <p>path to image file.</p> required <code>crop_ratio</code> <code>Optional[float]</code> <p>width to height ratio to crop the master image to. 1 results in a square image.</p> <code>None</code> <code>img_size</code> <code>Optional[Tuple[int, int]]</code> <p>resize the image to the provided size, width followed by height.</p> <code>None</code> <code>mode</code> <code>Optional[str]</code> <p>convert the image to the provided mode. See PIL Modes.</p> <code>None</code> <p>Returns:</p> Type Description <code>Master</code> <p>Master image instance.</p> <p>Examples:</p> <p>For black and white square 1280x1280 image.</p> <pre><code>&gt;&gt;&gt; Master.from_file(\"master.png\", crop_ratio=1, img_size=(1280, 1280), convert=\"L\")\n</code></pre> Source code in <code>phomo/master.py</code> <pre><code>@classmethod\ndef from_file(\n    cls,\n    master_image_file: PathLike,\n    crop_ratio: Optional[float] = None,\n    img_size: Optional[Tuple[int, int]] = None,\n    mode: Optional[str] = None,\n) -&gt; \"Master\":\n    \"\"\"Create a master image from file.\n\n    Args:\n        master_image_file: path to image file.\n        crop_ratio: width to height ratio to crop the master image to. 1 results in a square image.\n        img_size: resize the image to the provided size, width followed by height.\n        mode: convert the image to the provided mode. See PIL Modes.\n\n    Returns:\n        Master image instance.\n\n    Examples:\n        For black and white square 1280x1280 image.\n\n        &gt;&gt;&gt; Master.from_file(\"master.png\", crop_ratio=1, img_size=(1280, 1280), convert=\"L\")\n    \"\"\"\n    img = open_img_file(\n        master_image_file, crop_ratio=crop_ratio, size=img_size, mode=mode\n    )\n    return cls.from_image(img)\n</code></pre>"},{"location":"reference/__init__/#phomo.Master.from_image","title":"<code>from_image(master_image)</code>  <code>classmethod</code>","text":"<p>Create a master image from PIL.Image.Image</p> <p>Parameters:</p> Name Type Description Default <code>master_image</code> <code>Image</code> <p><code>PIL.Image</code> instance.</p> required <p>Returns:</p> Type Description <code>Master</code> <p>Master image instance.</p> Source code in <code>phomo/master.py</code> <pre><code>@classmethod\ndef from_image(cls, master_image: Image.Image) -&gt; \"Master\":\n    \"\"\"Create a master image from PIL.Image.Image\n\n    Args:\n        master_image: `PIL.Image` instance.\n\n    Returns:\n        Master image instance.\n    \"\"\"\n    array = np.asarray(master_image)\n    # make sure the arrays have 3 channels even in black and white\n    if array.ndim == 2:\n        array = np.stack([array] * 3, -1)\n    return cls(array)\n</code></pre>"},{"location":"reference/__init__/#phomo.Mosaic","title":"<code>Mosaic</code>","text":"Source code in <code>phomo/mosaic.py</code> <pre><code>class Mosaic:\n    @classmethod\n    def from_file_and_dir(\n        cls,\n        master_file: PathLike,\n        tile_dir: PathLike,\n        *args,\n        master_crop_ratio: Optional[float] = None,\n        master_size: Optional[Tuple[int, int]] = None,\n        master_mode: Optional[str] = None,\n        tile_crop_ratio: Optional[float] = None,\n        tile_size: Optional[Tuple[int, int]] = None,\n        tile_mode: Optional[str] = None,\n        **kwargs,\n    ) -&gt; \"Mosaic\":\n        \"\"\"Construct a `Mosaic` from a master image file and a directory containing the file images.\n\n        Args:\n            master_file: The master image file.\n            tile_dir: the directory containing the tile images.\n\n        Returns:\n            A `Mosaic` to construct the `master_file` using the tile images in the `tile_dir`.\n        \"\"\"\n        master = Master.from_file(\n            master_file,\n            crop_ratio=master_crop_ratio,\n            img_size=master_size,\n            mode=master_mode,\n        )\n        pool = Pool.from_dir(\n            tile_dir, tile_size=tile_size, crop_ratio=tile_crop_ratio, mode=tile_mode\n        )\n        return cls(master, pool, *args, **kwargs)\n\n    def __init__(\n        self,\n        master: Master,\n        pool: Pool,\n        n_appearances: int = 1,\n    ) -&gt; None:\n        \"\"\"Construct a regular grid mosaic.\n\n        Note:\n            The Pool's tiles should all be the same size.\n\n        Args:\n            master: `Master` image to reconstruct.\n            pool: Tile image pool with which to reconstruct the `Master` image.\n            n_appearances: Number of times a tile can appear in the mosaic.\n\n        Examples:\n            Building a mosaic.\n\n            &gt;&gt;&gt; pool = Pool.from_dir(\"tiles\")\n            &gt;&gt;&gt; master = Master.from_file(\"master.png\")\n            &gt;&gt;&gt; mosaic = Mosaic(master, pool, n_appearances=1)\n            &gt;&gt;&gt; mosaic.build(mosaic.d_matrix())\n        \"\"\"\n        self.master = master\n        if len(set([array.size for array in pool.array])) != 1:\n            raise ValueError(\"Pool tiles sizes are not identical.\")\n        self.pool = pool\n        self.tile_shape = (self.pool.array[0].shape[0], self.pool.array[0].shape[1])\n        self.n_appearances = n_appearances\n        self.grid = Grid(self.master, (self.size[1], self.size[0]), self.tile_shape)\n\n    @property\n    def size(self) -&gt; Tuple[int, int]:\n        \"\"\"The size of the mosaic image.\n\n        It can be different from the master image size as an integer number of\n        tiles should fit within it.\n\n        Returns:\n            The width and height of the mosaic image.\n        \"\"\"\n        return (\n            self.master.array.shape[1]\n            - self.master.array.shape[1] % self.tile_shape[1],\n            self.master.array.shape[0]\n            - self.master.array.shape[0] % self.tile_shape[0],\n        )\n\n    @property\n    def n_leftover(self) -&gt; int:\n        \"\"\"The number of tiles which will be unused when building the mosaic.\"\"\"\n        return len(self.pool) * self.n_appearances - len(self.grid.slices)\n\n    def _d_matrix_worker(\n        self, array: np.ndarray, metric_func: MetricCallable, **kwargs\n    ) -&gt; np.ndarray:\n        \"\"\"Parallel worker. Computes one row of the distance matrix.\"\"\"\n        # if the tile grid was subdivided the master array can be smaller\n        # than the tiles, need to resize to match the shapes\n        if array.shape[:-1] != self.tile_shape:\n            # this isn't exact because we are upscalling the master array\n            # we should be shrinking all the tile arrays but that is slower\n            array = resize_array(array, (self.tile_shape[1], self.tile_shape[0]))\n        return metric_func(array, self.pool.array, **kwargs)\n\n    def d_matrix(\n        self,\n        workers: int = 1,\n        metric: Union[str, MetricCallable] = \"norm\",\n        **kwargs,\n    ) -&gt; np.ndarray:\n        \"\"\"Compute the distance matrix between all the master's tiles and the\n        pool tiles.\n\n        Args:\n            workers: The number of worker to use.\n            metric: The distance metric used for the distance matrix. Either\n                provide a string, for implemented metrics see ``phomo.metrics.METRICS``.\n                Or a callable, which should take two ``np.ndarray``s and return a float.\n            **kwargs: Passed to `metric`.\n\n        Returns:\n            Distance matrix, shape: (number of master arrays, number of tiles in the pool).\n        \"\"\"\n        if isinstance(metric, str):\n            if metric not in METRICS.keys():\n                raise KeyError(\n                    \"'%s' not in available metrics: %s\",\n                    metric,\n                    repr(list(METRICS.keys())),\n                )\n            LOGGER.info(\"Using metric '%s'\", metric)\n            metric_func = METRICS[metric]\n        else:\n            LOGGER.info(\"Using user provided distance metric function.\")\n            metric_func = metric\n\n        # Compute the distance matrix.\n        worker = partial(self._d_matrix_worker, metric_func=metric_func, **kwargs)\n        if workers != 1:\n            LOGGER.info(\"Computing distance matrix with %i workers.\", workers)\n            with MpPool(processes=workers) as pool:\n                d_matrix = np.array(\n                    list(\n                        tqdm(\n                            pool.imap(\n                                worker,\n                                self.grid.arrays,\n                                chunksize=len(self.grid) // workers,\n                            ),\n                            total=len(self.grid.slices),\n                            desc=\"Building distance matrix\",\n                        )\n                    )\n                )\n        else:\n            # get rid of pool overhead if serial computation is desired.\n            LOGGER.info(\"Computing distance matrix in serial.\")\n            d_matrix = np.array(\n                [\n                    worker(array)\n                    for array in tqdm(self.grid.arrays, desc=\"Building distance matrix\")\n                ]\n            )\n        LOGGER.debug(\"d_matrix shape: %s\", d_matrix.shape)\n        return d_matrix\n\n    def d_matrix_cuda(self, metric: str = \"norm\") -&gt; np.ndarray:\n        \"\"\"Compute the distance matrix using CUDA for GPU acceleration.\n\n        Args:\n            metric: The distance metric used for the distance matrix. Either \"norm\" or \"greyscale\".\n\n        Returns:\n            Distance matrix, shape: (number of master arrays, number of tiles in the pool).\n        \"\"\"\n\n        try:\n            from numba import cuda\n        except ImportError:\n            raise ImportError(\n                \"Numba is required for CUDA support, run \\\"pip install 'phomo[cuda]'\\\" to install it.\"\n            )\n\n        if metric not in [\"norm\", \"greyscale\"]:\n            raise ValueError(\n                f\"Invalid metric '{metric}'. When using gpu `metric' must be 'norm' or 'greyscale'.\"\n            )\n\n        LOGGER.info(\"Computing distance matrix with CUDA.\")\n\n        # when the grid has been subdivided the master arrays will be smaller, so we grow them to match\n        # the tile size\n        grid_arrays = [\n            array\n            if array.shape == self.tile_shape\n            else resize_array(array, self.tile_shape)\n            for array in self.grid.arrays\n        ]\n        pool_arrays = self.pool.array\n        if metric == \"greyscale\":\n            grid_arrays = [array.sum(axis=-1, keepdims=True) for array in grid_arrays]\n            pool_arrays = [array.sum(axis=-1, keepdims=True) for array in pool_arrays]\n\n        # Transfer the master and pool arrays to the GPU.\n        master_arrays_device = cuda.to_device(grid_arrays)\n        pool_arrays_device = cuda.to_device(pool_arrays)\n\n        # Allocate memory for the distance matrix on the GPU.\n        d_matrix_device = cuda.device_array((len(grid_arrays), len(pool_arrays)))\n\n        # Define the CUDA kernel for computing the distance matrix.\n        @cuda.jit\n        def compute_d_matrix_kernel(master_arrays, pool_arrays, d_matrix):\n            i, j = cuda.grid(2)  # type: ignore\n            if i &lt; master_arrays.shape[0] and j &lt; pool_arrays.shape[0]:\n                distance = 0.0\n                for x in range(master_arrays.shape[1]):\n                    for y in range(master_arrays.shape[2]):\n                        for c in range(master_arrays.shape[3]):\n                            diff = master_arrays[i, x, y, c] - pool_arrays[j, x, y, c]\n                            distance += diff * diff\n                d_matrix[i, j] = math.sqrt(distance)\n\n        # Define the number of threads per block and blocks per grid.\n        threads_per_block = (16, 16)\n        blocks_per_grid_x = math.ceil(len(grid_arrays) / threads_per_block[0])\n        blocks_per_grid_y = math.ceil(len(pool_arrays) / threads_per_block[1])\n        blocks_per_grid = (blocks_per_grid_x, blocks_per_grid_y)\n\n        # Launch the kernel.\n        compute_d_matrix_kernel[blocks_per_grid, threads_per_block](  # type: ignore\n            master_arrays_device, pool_arrays_device, d_matrix_device\n        )\n\n        LOGGER.debug(\"d_matrix shape: %s\", d_matrix_device.shape)\n        # Copy the result back to the host.\n        return d_matrix_device.copy_to_host()\n\n    def build_greedy(self, d_matrix: np.ndarray) -&gt; Image.Image:\n        \"\"\"Construct the mosaic image using a greedy tile assignement algorithm.\n\n        This leads to less accurate mosaics, but is significantly faster than the\n        optimal assignement algorithm, especialy when the distance matrix is large.\n\n        Args:\n            d_matrix: The computed distance matrix.\n\n        Returns:\n            The `PIL.Image` instance of the mosaic.\n        \"\"\"\n        mosaic = np.zeros((self.size[1], self.size[0], 3))\n\n        # Keep track of tiles and sub arrays.\n        placed_master_arrays = set()\n        placed_tiles = set()\n        n_appearances = [0] * len(self.pool)\n\n        pbar = tqdm(total=d_matrix.shape[0], desc=\"Building mosaic\")\n        # from: https://stackoverflow.com/questions/29046162/numpy-array-loss-of-dimension-when-masking\n        sorted_master_slices_i, sorted_tiles = np.unravel_index(\n            np.argsort(d_matrix, axis=None), d_matrix.shape\n        )\n        for slices_i, tile in zip(sorted_master_slices_i, sorted_tiles):\n            if slices_i in placed_master_arrays or tile in placed_tiles:\n                continue\n            slices = self.grid.slices[slices_i]\n            tile_array = self.pool.array[tile]\n            # if the grid has been subdivided then the tile should be shrunk to\n            # the size of the subdivision\n            array_size = (\n                slices[1].stop - slices[1].start,\n                slices[0].stop - slices[0].start,\n            )\n            if tile_array.shape[:-1] != array_size[::-1]:\n                tile_array = resize_array(tile_array, array_size)\n\n            # shift slices back so that the centering of the mosaic within the\n            # master image is removed\n            slices = self.grid.remove_origin(slices)\n            mosaic[slices[0], slices[1]] = tile_array\n            placed_master_arrays.add(slices_i)\n            n_appearances[tile] += 1\n            if n_appearances[tile] == self.n_appearances:\n                placed_tiles.add(tile)\n            pbar.update(1)\n        pbar.close()\n        return Image.fromarray(np.uint8(mosaic))\n\n    def build(self, d_matrix: np.ndarray) -&gt; Image.Image:\n        \"\"\"Construct the mosaic image by solving the linear sum assignment problem.\n        See: https://en.wikipedia.org/wiki/Assignment_problem\n\n        Args:\n            d_matrix: The computed distance matrix.\n\n        Returns:\n            The `PIL.Image` instance of the mosaic.\n\n        Examples:\n            Building a mosaic.\n\n            &gt;&gt;&gt; mosaic.build(mosaic.d_matrix())\n\n            On a GPU.\n\n            &gt;&gt;&gt; mosaic.build(mosaic.d_matrix_cuda())\n        \"\"\"\n        mosaic = np.zeros((self.size[1], self.size[0], 3))\n\n        # expand the dmatrix to allow for repeated tiles\n        if self.n_appearances &gt; 0:\n            d_matrix = np.tile(d_matrix, self.n_appearances)\n\n        LOGGER.info(\"Computing optimal tile assignment.\")\n        row_ind, col_ind = linear_sum_assignment(d_matrix)\n        pbar = tqdm(total=d_matrix.shape[0], desc=\"Building mosaic\")\n        for row, col in zip(row_ind, col_ind):\n            slices = self.grid.slices[row]\n            tile_array = self.pool.array[col % len(self.pool.array)]\n            # if the grid has been subdivided then the tile should be shrunk to\n            # the size of the subdivision\n            array_size = (\n                slices[1].stop - slices[1].start,\n                slices[0].stop - slices[0].start,\n            )\n            if tile_array.shape[:-1] != array_size[::-1]:\n                tile_array = resize_array(tile_array, array_size)\n\n            # shift slices back so that the centering of the mosaic within the\n            # master image is removed\n            slices = self.grid.remove_origin(slices)\n            mosaic[slices[0], slices[1]] = tile_array\n            pbar.update(1)\n        pbar.close()\n\n        return Image.fromarray(np.uint8(mosaic))\n\n    def __repr__(self) -&gt; str:\n        # indent these guys\n        master = repr(self.master).replace(\"\\n\", \"\\n    \")\n        pool = repr(self.pool).replace(\"\\n\", \"\\n    \")\n        grid = repr(self.grid).replace(\"\\n\", \"\\n    \")\n        return f\"\"\"{self.__class__.__module__}.{self.__class__.__name__} at {hex(id(self))}:\n    n_appearances: {self.n_appearances}\n    mosaic size: {self.size}\n    tile shape: {self.tile_shape}\n    leftover tiles: {self.n_leftover}\n    {grid}\n    {master}\n    {pool}\"\"\"\n</code></pre>"},{"location":"reference/__init__/#phomo.Mosaic.n_leftover","title":"<code>n_leftover: int</code>  <code>property</code>","text":"<p>The number of tiles which will be unused when building the mosaic.</p>"},{"location":"reference/__init__/#phomo.Mosaic.size","title":"<code>size: Tuple[int, int]</code>  <code>property</code>","text":"<p>The size of the mosaic image.</p> <p>It can be different from the master image size as an integer number of tiles should fit within it.</p> <p>Returns:</p> Type Description <code>Tuple[int, int]</code> <p>The width and height of the mosaic image.</p>"},{"location":"reference/__init__/#phomo.Mosaic.__init__","title":"<code>__init__(master, pool, n_appearances=1)</code>","text":"<p>Construct a regular grid mosaic.</p> Note <p>The Pool's tiles should all be the same size.</p> <p>Parameters:</p> Name Type Description Default <code>master</code> <code>Master</code> <p><code>Master</code> image to reconstruct.</p> required <code>pool</code> <code>Pool</code> <p>Tile image pool with which to reconstruct the <code>Master</code> image.</p> required <code>n_appearances</code> <code>int</code> <p>Number of times a tile can appear in the mosaic.</p> <code>1</code> <p>Examples:</p> <p>Building a mosaic.</p> <pre><code>&gt;&gt;&gt; pool = Pool.from_dir(\"tiles\")\n&gt;&gt;&gt; master = Master.from_file(\"master.png\")\n&gt;&gt;&gt; mosaic = Mosaic(master, pool, n_appearances=1)\n&gt;&gt;&gt; mosaic.build(mosaic.d_matrix())\n</code></pre> Source code in <code>phomo/mosaic.py</code> <pre><code>def __init__(\n    self,\n    master: Master,\n    pool: Pool,\n    n_appearances: int = 1,\n) -&gt; None:\n    \"\"\"Construct a regular grid mosaic.\n\n    Note:\n        The Pool's tiles should all be the same size.\n\n    Args:\n        master: `Master` image to reconstruct.\n        pool: Tile image pool with which to reconstruct the `Master` image.\n        n_appearances: Number of times a tile can appear in the mosaic.\n\n    Examples:\n        Building a mosaic.\n\n        &gt;&gt;&gt; pool = Pool.from_dir(\"tiles\")\n        &gt;&gt;&gt; master = Master.from_file(\"master.png\")\n        &gt;&gt;&gt; mosaic = Mosaic(master, pool, n_appearances=1)\n        &gt;&gt;&gt; mosaic.build(mosaic.d_matrix())\n    \"\"\"\n    self.master = master\n    if len(set([array.size for array in pool.array])) != 1:\n        raise ValueError(\"Pool tiles sizes are not identical.\")\n    self.pool = pool\n    self.tile_shape = (self.pool.array[0].shape[0], self.pool.array[0].shape[1])\n    self.n_appearances = n_appearances\n    self.grid = Grid(self.master, (self.size[1], self.size[0]), self.tile_shape)\n</code></pre>"},{"location":"reference/__init__/#phomo.Mosaic.build","title":"<code>build(d_matrix)</code>","text":"<p>Construct the mosaic image by solving the linear sum assignment problem. See: https://en.wikipedia.org/wiki/Assignment_problem</p> <p>Parameters:</p> Name Type Description Default <code>d_matrix</code> <code>ndarray</code> <p>The computed distance matrix.</p> required <p>Returns:</p> Type Description <code>Image</code> <p>The <code>PIL.Image</code> instance of the mosaic.</p> <p>Examples:</p> <p>Building a mosaic.</p> <pre><code>&gt;&gt;&gt; mosaic.build(mosaic.d_matrix())\n</code></pre> <p>On a GPU.</p> <pre><code>&gt;&gt;&gt; mosaic.build(mosaic.d_matrix_cuda())\n</code></pre> Source code in <code>phomo/mosaic.py</code> <pre><code>def build(self, d_matrix: np.ndarray) -&gt; Image.Image:\n    \"\"\"Construct the mosaic image by solving the linear sum assignment problem.\n    See: https://en.wikipedia.org/wiki/Assignment_problem\n\n    Args:\n        d_matrix: The computed distance matrix.\n\n    Returns:\n        The `PIL.Image` instance of the mosaic.\n\n    Examples:\n        Building a mosaic.\n\n        &gt;&gt;&gt; mosaic.build(mosaic.d_matrix())\n\n        On a GPU.\n\n        &gt;&gt;&gt; mosaic.build(mosaic.d_matrix_cuda())\n    \"\"\"\n    mosaic = np.zeros((self.size[1], self.size[0], 3))\n\n    # expand the dmatrix to allow for repeated tiles\n    if self.n_appearances &gt; 0:\n        d_matrix = np.tile(d_matrix, self.n_appearances)\n\n    LOGGER.info(\"Computing optimal tile assignment.\")\n    row_ind, col_ind = linear_sum_assignment(d_matrix)\n    pbar = tqdm(total=d_matrix.shape[0], desc=\"Building mosaic\")\n    for row, col in zip(row_ind, col_ind):\n        slices = self.grid.slices[row]\n        tile_array = self.pool.array[col % len(self.pool.array)]\n        # if the grid has been subdivided then the tile should be shrunk to\n        # the size of the subdivision\n        array_size = (\n            slices[1].stop - slices[1].start,\n            slices[0].stop - slices[0].start,\n        )\n        if tile_array.shape[:-1] != array_size[::-1]:\n            tile_array = resize_array(tile_array, array_size)\n\n        # shift slices back so that the centering of the mosaic within the\n        # master image is removed\n        slices = self.grid.remove_origin(slices)\n        mosaic[slices[0], slices[1]] = tile_array\n        pbar.update(1)\n    pbar.close()\n\n    return Image.fromarray(np.uint8(mosaic))\n</code></pre>"},{"location":"reference/__init__/#phomo.Mosaic.build_greedy","title":"<code>build_greedy(d_matrix)</code>","text":"<p>Construct the mosaic image using a greedy tile assignement algorithm.</p> <p>This leads to less accurate mosaics, but is significantly faster than the optimal assignement algorithm, especialy when the distance matrix is large.</p> <p>Parameters:</p> Name Type Description Default <code>d_matrix</code> <code>ndarray</code> <p>The computed distance matrix.</p> required <p>Returns:</p> Type Description <code>Image</code> <p>The <code>PIL.Image</code> instance of the mosaic.</p> Source code in <code>phomo/mosaic.py</code> <pre><code>def build_greedy(self, d_matrix: np.ndarray) -&gt; Image.Image:\n    \"\"\"Construct the mosaic image using a greedy tile assignement algorithm.\n\n    This leads to less accurate mosaics, but is significantly faster than the\n    optimal assignement algorithm, especialy when the distance matrix is large.\n\n    Args:\n        d_matrix: The computed distance matrix.\n\n    Returns:\n        The `PIL.Image` instance of the mosaic.\n    \"\"\"\n    mosaic = np.zeros((self.size[1], self.size[0], 3))\n\n    # Keep track of tiles and sub arrays.\n    placed_master_arrays = set()\n    placed_tiles = set()\n    n_appearances = [0] * len(self.pool)\n\n    pbar = tqdm(total=d_matrix.shape[0], desc=\"Building mosaic\")\n    # from: https://stackoverflow.com/questions/29046162/numpy-array-loss-of-dimension-when-masking\n    sorted_master_slices_i, sorted_tiles = np.unravel_index(\n        np.argsort(d_matrix, axis=None), d_matrix.shape\n    )\n    for slices_i, tile in zip(sorted_master_slices_i, sorted_tiles):\n        if slices_i in placed_master_arrays or tile in placed_tiles:\n            continue\n        slices = self.grid.slices[slices_i]\n        tile_array = self.pool.array[tile]\n        # if the grid has been subdivided then the tile should be shrunk to\n        # the size of the subdivision\n        array_size = (\n            slices[1].stop - slices[1].start,\n            slices[0].stop - slices[0].start,\n        )\n        if tile_array.shape[:-1] != array_size[::-1]:\n            tile_array = resize_array(tile_array, array_size)\n\n        # shift slices back so that the centering of the mosaic within the\n        # master image is removed\n        slices = self.grid.remove_origin(slices)\n        mosaic[slices[0], slices[1]] = tile_array\n        placed_master_arrays.add(slices_i)\n        n_appearances[tile] += 1\n        if n_appearances[tile] == self.n_appearances:\n            placed_tiles.add(tile)\n        pbar.update(1)\n    pbar.close()\n    return Image.fromarray(np.uint8(mosaic))\n</code></pre>"},{"location":"reference/__init__/#phomo.Mosaic.d_matrix","title":"<code>d_matrix(workers=1, metric='norm', **kwargs)</code>","text":"<p>Compute the distance matrix between all the master's tiles and the pool tiles.</p> <p>Parameters:</p> Name Type Description Default <code>workers</code> <code>int</code> <p>The number of worker to use.</p> <code>1</code> <code>metric</code> <code>Union[str, MetricCallable]</code> <p>The distance metric used for the distance matrix. Either provide a string, for implemented metrics see <code>phomo.metrics.METRICS</code>. Or a callable, which should take two <code>np.ndarray</code>s and return a float.</p> <code>'norm'</code> <code>**kwargs</code> <p>Passed to <code>metric</code>.</p> <code>{}</code> <p>Returns:</p> Type Description <code>ndarray</code> <p>Distance matrix, shape: (number of master arrays, number of tiles in the pool).</p> Source code in <code>phomo/mosaic.py</code> <pre><code>def d_matrix(\n    self,\n    workers: int = 1,\n    metric: Union[str, MetricCallable] = \"norm\",\n    **kwargs,\n) -&gt; np.ndarray:\n    \"\"\"Compute the distance matrix between all the master's tiles and the\n    pool tiles.\n\n    Args:\n        workers: The number of worker to use.\n        metric: The distance metric used for the distance matrix. Either\n            provide a string, for implemented metrics see ``phomo.metrics.METRICS``.\n            Or a callable, which should take two ``np.ndarray``s and return a float.\n        **kwargs: Passed to `metric`.\n\n    Returns:\n        Distance matrix, shape: (number of master arrays, number of tiles in the pool).\n    \"\"\"\n    if isinstance(metric, str):\n        if metric not in METRICS.keys():\n            raise KeyError(\n                \"'%s' not in available metrics: %s\",\n                metric,\n                repr(list(METRICS.keys())),\n            )\n        LOGGER.info(\"Using metric '%s'\", metric)\n        metric_func = METRICS[metric]\n    else:\n        LOGGER.info(\"Using user provided distance metric function.\")\n        metric_func = metric\n\n    # Compute the distance matrix.\n    worker = partial(self._d_matrix_worker, metric_func=metric_func, **kwargs)\n    if workers != 1:\n        LOGGER.info(\"Computing distance matrix with %i workers.\", workers)\n        with MpPool(processes=workers) as pool:\n            d_matrix = np.array(\n                list(\n                    tqdm(\n                        pool.imap(\n                            worker,\n                            self.grid.arrays,\n                            chunksize=len(self.grid) // workers,\n                        ),\n                        total=len(self.grid.slices),\n                        desc=\"Building distance matrix\",\n                    )\n                )\n            )\n    else:\n        # get rid of pool overhead if serial computation is desired.\n        LOGGER.info(\"Computing distance matrix in serial.\")\n        d_matrix = np.array(\n            [\n                worker(array)\n                for array in tqdm(self.grid.arrays, desc=\"Building distance matrix\")\n            ]\n        )\n    LOGGER.debug(\"d_matrix shape: %s\", d_matrix.shape)\n    return d_matrix\n</code></pre>"},{"location":"reference/__init__/#phomo.Mosaic.d_matrix_cuda","title":"<code>d_matrix_cuda(metric='norm')</code>","text":"<p>Compute the distance matrix using CUDA for GPU acceleration.</p> <p>Parameters:</p> Name Type Description Default <code>metric</code> <code>str</code> <p>The distance metric used for the distance matrix. Either \"norm\" or \"greyscale\".</p> <code>'norm'</code> <p>Returns:</p> Type Description <code>ndarray</code> <p>Distance matrix, shape: (number of master arrays, number of tiles in the pool).</p> Source code in <code>phomo/mosaic.py</code> <pre><code>def d_matrix_cuda(self, metric: str = \"norm\") -&gt; np.ndarray:\n    \"\"\"Compute the distance matrix using CUDA for GPU acceleration.\n\n    Args:\n        metric: The distance metric used for the distance matrix. Either \"norm\" or \"greyscale\".\n\n    Returns:\n        Distance matrix, shape: (number of master arrays, number of tiles in the pool).\n    \"\"\"\n\n    try:\n        from numba import cuda\n    except ImportError:\n        raise ImportError(\n            \"Numba is required for CUDA support, run \\\"pip install 'phomo[cuda]'\\\" to install it.\"\n        )\n\n    if metric not in [\"norm\", \"greyscale\"]:\n        raise ValueError(\n            f\"Invalid metric '{metric}'. When using gpu `metric' must be 'norm' or 'greyscale'.\"\n        )\n\n    LOGGER.info(\"Computing distance matrix with CUDA.\")\n\n    # when the grid has been subdivided the master arrays will be smaller, so we grow them to match\n    # the tile size\n    grid_arrays = [\n        array\n        if array.shape == self.tile_shape\n        else resize_array(array, self.tile_shape)\n        for array in self.grid.arrays\n    ]\n    pool_arrays = self.pool.array\n    if metric == \"greyscale\":\n        grid_arrays = [array.sum(axis=-1, keepdims=True) for array in grid_arrays]\n        pool_arrays = [array.sum(axis=-1, keepdims=True) for array in pool_arrays]\n\n    # Transfer the master and pool arrays to the GPU.\n    master_arrays_device = cuda.to_device(grid_arrays)\n    pool_arrays_device = cuda.to_device(pool_arrays)\n\n    # Allocate memory for the distance matrix on the GPU.\n    d_matrix_device = cuda.device_array((len(grid_arrays), len(pool_arrays)))\n\n    # Define the CUDA kernel for computing the distance matrix.\n    @cuda.jit\n    def compute_d_matrix_kernel(master_arrays, pool_arrays, d_matrix):\n        i, j = cuda.grid(2)  # type: ignore\n        if i &lt; master_arrays.shape[0] and j &lt; pool_arrays.shape[0]:\n            distance = 0.0\n            for x in range(master_arrays.shape[1]):\n                for y in range(master_arrays.shape[2]):\n                    for c in range(master_arrays.shape[3]):\n                        diff = master_arrays[i, x, y, c] - pool_arrays[j, x, y, c]\n                        distance += diff * diff\n            d_matrix[i, j] = math.sqrt(distance)\n\n    # Define the number of threads per block and blocks per grid.\n    threads_per_block = (16, 16)\n    blocks_per_grid_x = math.ceil(len(grid_arrays) / threads_per_block[0])\n    blocks_per_grid_y = math.ceil(len(pool_arrays) / threads_per_block[1])\n    blocks_per_grid = (blocks_per_grid_x, blocks_per_grid_y)\n\n    # Launch the kernel.\n    compute_d_matrix_kernel[blocks_per_grid, threads_per_block](  # type: ignore\n        master_arrays_device, pool_arrays_device, d_matrix_device\n    )\n\n    LOGGER.debug(\"d_matrix shape: %s\", d_matrix_device.shape)\n    # Copy the result back to the host.\n    return d_matrix_device.copy_to_host()\n</code></pre>"},{"location":"reference/__init__/#phomo.Mosaic.from_file_and_dir","title":"<code>from_file_and_dir(master_file, tile_dir, *args, master_crop_ratio=None, master_size=None, master_mode=None, tile_crop_ratio=None, tile_size=None, tile_mode=None, **kwargs)</code>  <code>classmethod</code>","text":"<p>Construct a <code>Mosaic</code> from a master image file and a directory containing the file images.</p> <p>Parameters:</p> Name Type Description Default <code>master_file</code> <code>PathLike</code> <p>The master image file.</p> required <code>tile_dir</code> <code>PathLike</code> <p>the directory containing the tile images.</p> required <p>Returns:</p> Type Description <code>Mosaic</code> <p>A <code>Mosaic</code> to construct the <code>master_file</code> using the tile images in the <code>tile_dir</code>.</p> Source code in <code>phomo/mosaic.py</code> <pre><code>@classmethod\ndef from_file_and_dir(\n    cls,\n    master_file: PathLike,\n    tile_dir: PathLike,\n    *args,\n    master_crop_ratio: Optional[float] = None,\n    master_size: Optional[Tuple[int, int]] = None,\n    master_mode: Optional[str] = None,\n    tile_crop_ratio: Optional[float] = None,\n    tile_size: Optional[Tuple[int, int]] = None,\n    tile_mode: Optional[str] = None,\n    **kwargs,\n) -&gt; \"Mosaic\":\n    \"\"\"Construct a `Mosaic` from a master image file and a directory containing the file images.\n\n    Args:\n        master_file: The master image file.\n        tile_dir: the directory containing the tile images.\n\n    Returns:\n        A `Mosaic` to construct the `master_file` using the tile images in the `tile_dir`.\n    \"\"\"\n    master = Master.from_file(\n        master_file,\n        crop_ratio=master_crop_ratio,\n        img_size=master_size,\n        mode=master_mode,\n    )\n    pool = Pool.from_dir(\n        tile_dir, tile_size=tile_size, crop_ratio=tile_crop_ratio, mode=tile_mode\n    )\n    return cls(master, pool, *args, **kwargs)\n</code></pre>"},{"location":"reference/__init__/#phomo.Pool","title":"<code>Pool</code>","text":"<p>               Bases: <code>Palette</code></p> Source code in <code>phomo/pool.py</code> <pre><code>class Pool(Palette):\n    @classmethod\n    def from_dir(\n        cls,\n        tile_dir: PathLike,\n        crop_ratio: Optional[float] = None,\n        tile_size: Optional[Tuple[int, int]] = None,\n        mode: Optional[str] = None,\n    ) -&gt; \"Pool\":\n        \"\"\"Create a `Pool` instance from the images in a directory.\n\n        Args:\n            tile_dir: path to directory containing the images.\n            crop_ratio: width to height ratio to crop the tile images to. 1 results in a\n                square image.\n            tile_size: resize the image to the provided size, width followed by height.\n            mode: convert the images to the provided mode.\n                See [PIL Modes](https://pillow.readthedocs.io/en/stable/handbook/concepts.html#modes).\n        \"\"\"\n        if not isinstance(tile_dir, Path):\n            tile_dir = Path(tile_dir)\n        if not tile_dir.is_dir():\n            raise ValueError(f\"'{tile_dir}' is not a directory.\")\n        array = cls._load_files(\n            list(tile_dir.glob(\"*\")),\n            crop_ratio=crop_ratio,\n            size=tile_size,\n            mode=mode,\n        )\n        return cls(array)\n\n    @classmethod\n    def from_files(\n        cls,\n        files: Sequence[PathLike],\n        crop_ratio: Optional[float] = None,\n        tile_size: Optional[Tuple[int, int]] = None,\n        mode: Optional[str] = None,\n    ) -&gt; \"Pool\":\n        \"\"\"Create a `Pool` instance from a list of images.\n\n        Args:\n            files: list of paths to the tile images.\n            crop_ratio: width to height ratio to crop the master image to. 1 results in a square image.\n            tile_size: resize the image to the provided size, width followed by height.\n            mode: mode the image to the provided mode.\n                See [PIL Modes](https://pillow.readthedocs.io/en/stable/handbook/concepts.html#modes).\n        \"\"\"\n        array = cls._load_files(files, crop_ratio=crop_ratio, size=tile_size, mode=mode)\n        return cls(array)\n\n    def __init__(\n        self,\n        array: ArrayLike,\n    ) -&gt; None:\n        \"\"\"A `Pool` of tile images, to use in contructing the photo mosaic.\n\n        Args:\n            array: `Pool` image data array. Should be (n_tiles, height, width, 3)\n        \"\"\"\n        super().__init__(array)\n\n    @property\n    def tiles(self) -&gt; \"PoolTiles\":\n        \"\"\"Access the Pool's tile images.\n\n        Examples:\n            Show the first image in the pool.\n\n            &gt;&gt;&gt; pool.tiles[0].show()\n        \"\"\"\n        return PoolTiles(self.array)\n\n    @property\n    def pixels(self) -&gt; np.ndarray:\n        \"\"\"Array containing the 3-channel pixel values of all the images in the Pool.\"\"\"\n        return np.vstack([array.reshape(-1, array.shape[-1]) for array in self.array])\n\n    @staticmethod\n    def _load_files(files: Sequence[PathLike], **kwargs) -&gt; List[np.ndarray]:\n        arrays = []\n        for tile in tqdm(files, desc=\"Loading tiles\"):\n            img = open_img_file(tile, **kwargs)\n            array = np.asarray(img)\n            # make sure the arrays have 3 channels even in black and white\n            if array.ndim == 2:\n                array = np.stack([array] * 3, -1)\n            arrays.append(array)\n        return arrays\n\n    def __len__(self) -&gt; int:\n        return len(self.array)\n\n    def __repr__(self) -&gt; str:\n        return f\"\"\"{self.__class__.__module__}.{self.__class__.__name__} at {hex(id(self))}:\n    len: {self.__len__()}\"\"\"\n</code></pre>"},{"location":"reference/__init__/#phomo.Pool.pixels","title":"<code>pixels: np.ndarray</code>  <code>property</code>","text":"<p>Array containing the 3-channel pixel values of all the images in the Pool.</p>"},{"location":"reference/__init__/#phomo.Pool.tiles","title":"<code>tiles: PoolTiles</code>  <code>property</code>","text":"<p>Access the Pool's tile images.</p> <p>Examples:</p> <p>Show the first image in the pool.</p> <pre><code>&gt;&gt;&gt; pool.tiles[0].show()\n</code></pre>"},{"location":"reference/__init__/#phomo.Pool.__init__","title":"<code>__init__(array)</code>","text":"<p>A <code>Pool</code> of tile images, to use in contructing the photo mosaic.</p> <p>Parameters:</p> Name Type Description Default <code>array</code> <code>ArrayLike</code> <p><code>Pool</code> image data array. Should be (n_tiles, height, width, 3)</p> required Source code in <code>phomo/pool.py</code> <pre><code>def __init__(\n    self,\n    array: ArrayLike,\n) -&gt; None:\n    \"\"\"A `Pool` of tile images, to use in contructing the photo mosaic.\n\n    Args:\n        array: `Pool` image data array. Should be (n_tiles, height, width, 3)\n    \"\"\"\n    super().__init__(array)\n</code></pre>"},{"location":"reference/__init__/#phomo.Pool.from_dir","title":"<code>from_dir(tile_dir, crop_ratio=None, tile_size=None, mode=None)</code>  <code>classmethod</code>","text":"<p>Create a <code>Pool</code> instance from the images in a directory.</p> <p>Parameters:</p> Name Type Description Default <code>tile_dir</code> <code>PathLike</code> <p>path to directory containing the images.</p> required <code>crop_ratio</code> <code>Optional[float]</code> <p>width to height ratio to crop the tile images to. 1 results in a square image.</p> <code>None</code> <code>tile_size</code> <code>Optional[Tuple[int, int]]</code> <p>resize the image to the provided size, width followed by height.</p> <code>None</code> <code>mode</code> <code>Optional[str]</code> <p>convert the images to the provided mode. See PIL Modes.</p> <code>None</code> Source code in <code>phomo/pool.py</code> <pre><code>@classmethod\ndef from_dir(\n    cls,\n    tile_dir: PathLike,\n    crop_ratio: Optional[float] = None,\n    tile_size: Optional[Tuple[int, int]] = None,\n    mode: Optional[str] = None,\n) -&gt; \"Pool\":\n    \"\"\"Create a `Pool` instance from the images in a directory.\n\n    Args:\n        tile_dir: path to directory containing the images.\n        crop_ratio: width to height ratio to crop the tile images to. 1 results in a\n            square image.\n        tile_size: resize the image to the provided size, width followed by height.\n        mode: convert the images to the provided mode.\n            See [PIL Modes](https://pillow.readthedocs.io/en/stable/handbook/concepts.html#modes).\n    \"\"\"\n    if not isinstance(tile_dir, Path):\n        tile_dir = Path(tile_dir)\n    if not tile_dir.is_dir():\n        raise ValueError(f\"'{tile_dir}' is not a directory.\")\n    array = cls._load_files(\n        list(tile_dir.glob(\"*\")),\n        crop_ratio=crop_ratio,\n        size=tile_size,\n        mode=mode,\n    )\n    return cls(array)\n</code></pre>"},{"location":"reference/__init__/#phomo.Pool.from_files","title":"<code>from_files(files, crop_ratio=None, tile_size=None, mode=None)</code>  <code>classmethod</code>","text":"<p>Create a <code>Pool</code> instance from a list of images.</p> <p>Parameters:</p> Name Type Description Default <code>files</code> <code>Sequence[PathLike]</code> <p>list of paths to the tile images.</p> required <code>crop_ratio</code> <code>Optional[float]</code> <p>width to height ratio to crop the master image to. 1 results in a square image.</p> <code>None</code> <code>tile_size</code> <code>Optional[Tuple[int, int]]</code> <p>resize the image to the provided size, width followed by height.</p> <code>None</code> <code>mode</code> <code>Optional[str]</code> <p>mode the image to the provided mode. See PIL Modes.</p> <code>None</code> Source code in <code>phomo/pool.py</code> <pre><code>@classmethod\ndef from_files(\n    cls,\n    files: Sequence[PathLike],\n    crop_ratio: Optional[float] = None,\n    tile_size: Optional[Tuple[int, int]] = None,\n    mode: Optional[str] = None,\n) -&gt; \"Pool\":\n    \"\"\"Create a `Pool` instance from a list of images.\n\n    Args:\n        files: list of paths to the tile images.\n        crop_ratio: width to height ratio to crop the master image to. 1 results in a square image.\n        tile_size: resize the image to the provided size, width followed by height.\n        mode: mode the image to the provided mode.\n            See [PIL Modes](https://pillow.readthedocs.io/en/stable/handbook/concepts.html#modes).\n    \"\"\"\n    array = cls._load_files(files, crop_ratio=crop_ratio, size=tile_size, mode=mode)\n    return cls(array)\n</code></pre>"},{"location":"reference/grid/","title":"grid","text":""},{"location":"reference/grid/#phomo.grid.Grid","title":"<code>Grid</code>","text":"Source code in <code>phomo/grid.py</code> <pre><code>class Grid:\n    def __init__(\n        self,\n        master: Master,\n        mosaic_shape: Tuple[int, int],\n        tile_shape: Tuple[int, int],\n    ) -&gt; None:\n        \"\"\"Mosaic tile grid.\n\n        Args:\n            master: Master image.\n            mosaic_shape: mosaic image shape.\n            tile_shape: size of the tiles.\n        \"\"\"\n        self.master = master\n        self.mosaic_shape = mosaic_shape\n        self.tile_shape = tile_shape\n        self.thresholds = []\n        self.origin = (\n            self.master.array.shape[0] % self.tile_shape[0] // 2,\n            self.master.array.shape[1] % self.tile_shape[1] // 2,\n        )\n        self._slices = None\n        self._arrays = None\n\n    @property\n    def arrays(self) -&gt; List[np.ndarray]:\n        \"\"\"List of arrays containing the pixel values of all the slices.\"\"\"\n        if self._arrays is None:\n            LOGGER.debug(\"Computing arrays.\")\n            self._arrays = [\n                self.master.array[slices[0], slices[1]] for slices in self.slices\n            ]\n        return self._arrays\n\n    @property\n    def slices(self) -&gt; List[Tuple[slice, slice]]:\n        \"\"\"Mosaic grid slices.\"\"\"\n        if self._slices is None:\n            LOGGER.debug(\"Computing slices.\")\n            self._slices = list(self._compute_slices())\n        return self._slices\n\n    def _compute_slices(self) -&gt; Iterator[Tuple[slice, slice]]:\n        for x in range(\n            self.origin[1], self.mosaic_shape[1] - self.origin[1], self.tile_shape[1]\n        ):\n            for y in range(\n                self.origin[0],\n                self.mosaic_shape[0] - self.origin[0],\n                self.tile_shape[0],\n            ):\n                yield (\n                    slice(y, y + self.tile_shape[0]),\n                    slice(x, x + self.tile_shape[1]),\n                )\n\n    def remove_origin(self, slices: Tuple[slice, slice]) -&gt; Tuple[slice, slice]:\n        \"\"\"Remove the origin of the mosaic from a slice tuple.\"\"\"\n        return (\n            slice(slices[0].start - self.origin[0], slices[0].stop - self.origin[0]),\n            slice(slices[1].start - self.origin[1], slices[1].stop - self.origin[1]),\n        )\n\n    @staticmethod\n    def _subdivide(\n        slices: Tuple[slice, slice],\n    ) -&gt; Tuple[\n        Tuple[slice, slice],\n        Tuple[slice, slice],\n        Tuple[slice, slice],\n        Tuple[slice, slice],\n    ]:\n        \"\"\"Create four tiles from the four quadrants of the input tile.\n\n        Examples:\n            Subdivide a grid element.\n\n            &gt;&gt;&gt; mosaic.grid._subdivide((slice(0, 30, None), slice(0, 45, None)))\n            ((slice(0, 15, None), slice(0, 22, None)),\n             (slice(0, 15, None), slice(22, 45, None)),\n             (slice(15, 30, None), slice(0, 22, None)),\n             (slice(15, 30, None), slice(22, 45, None)))\n        \"\"\"\n        height = slices[0].stop - slices[0].start\n        width = slices[1].stop - slices[1].start\n        tile_dims = [(s.stop - s.start) // 2 for s in slices]\n        return (\n            (\n                slice(slices[0].start, slices[0].start + tile_dims[0]),\n                slice(slices[1].start, slices[1].start + tile_dims[1]),\n            ),\n            (\n                slice(slices[0].start, slices[0].start + tile_dims[0]),\n                slice(\n                    slices[1].start + tile_dims[1],\n                    slices[1].start + 2 * tile_dims[1] + width % 2,\n                ),\n            ),\n            (\n                slice(\n                    slices[0].start + tile_dims[0],\n                    slices[0].start + 2 * tile_dims[0] + height % 2,\n                ),\n                slice(slices[1].start, slices[1].start + tile_dims[1]),\n            ),\n            (\n                slice(\n                    slices[0].start + tile_dims[0],\n                    slices[0].start + 2 * tile_dims[0] + height % 2,\n                ),\n                slice(\n                    slices[1].start + tile_dims[1],\n                    slices[1].start + 2 * tile_dims[1] + width % 2,\n                ),\n            ),\n        )\n\n    def _yield_subdivide(self, threshold: float) -&gt; Iterator[Tuple[slice, slice]]:\n        n_divisions = 0\n        for i, slices in enumerate(self.slices):\n            pixels = self.master.array[slices[0], slices[1]].reshape(-1, 3)\n            contrast = np.mean(np.std(pixels / 255, axis=0))\n            LOGGER.debug(\"Contrast slice %i: %f\", i, contrast)\n            if contrast &gt; threshold:\n                LOGGER.debug(\"Dividing slice %i\", i)\n                yield from self._subdivide(slices)\n                n_divisions += 1\n            else:\n                yield slices\n        LOGGER.info(\"Subdivided %i tiles.\", n_divisions)\n\n    def subdivide(self, threshold: float) -&gt; None:\n        \"\"\"Subdivide grid based on contrast.\n\n        Note:\n            Modifies the grid in place.\n\n        Args:\n            threshold: contrast threshold at which to divide the slice into 4\n                smaller slices. Between 0 and 1.\n        \"\"\"\n        LOGGER.info(\"Subdividing with threshold %f\", threshold)\n        self._slices = list(self._yield_subdivide(threshold))\n        # clear the cached arrays\n        self._arrays = None\n        self.thresholds.append(threshold)\n\n    def plot(self, colour: Tuple[int, int, int] = (255, 255, 255)) -&gt; Image.Image:\n        \"\"\"Draw the tile edges on a copy of master image image.\n\n        Args:\n            colour: Colour of tile edges.\n\n        Returns:\n            Master image with the tile grid overlayed ontop.\n        \"\"\"\n        annotated_image = self.master.array.copy()\n        for y, x in self.slices:\n            annotated_image[y, x.start] = colour\n            annotated_image[y, x.stop - 1] = colour\n            annotated_image[y.start, x] = colour\n            annotated_image[y.stop - 1, x] = colour\n        return Image.fromarray(annotated_image)\n\n    def __len__(self) -&gt; int:\n        return len(self.slices)\n\n    def __repr__(self) -&gt; str:\n        return f\"\"\"{self.__class__.__module__}.{self.__class__.__name__} at {hex(id(self))}:\n    origin: {self.origin}\n    len slices: {len(self.slices)}\n    thresholds: {self.thresholds}\"\"\"\n</code></pre>"},{"location":"reference/grid/#phomo.grid.Grid.arrays","title":"<code>arrays: List[np.ndarray]</code>  <code>property</code>","text":"<p>List of arrays containing the pixel values of all the slices.</p>"},{"location":"reference/grid/#phomo.grid.Grid.slices","title":"<code>slices: List[Tuple[slice, slice]]</code>  <code>property</code>","text":"<p>Mosaic grid slices.</p>"},{"location":"reference/grid/#phomo.grid.Grid.__init__","title":"<code>__init__(master, mosaic_shape, tile_shape)</code>","text":"<p>Mosaic tile grid.</p> <p>Parameters:</p> Name Type Description Default <code>master</code> <code>Master</code> <p>Master image.</p> required <code>mosaic_shape</code> <code>Tuple[int, int]</code> <p>mosaic image shape.</p> required <code>tile_shape</code> <code>Tuple[int, int]</code> <p>size of the tiles.</p> required Source code in <code>phomo/grid.py</code> <pre><code>def __init__(\n    self,\n    master: Master,\n    mosaic_shape: Tuple[int, int],\n    tile_shape: Tuple[int, int],\n) -&gt; None:\n    \"\"\"Mosaic tile grid.\n\n    Args:\n        master: Master image.\n        mosaic_shape: mosaic image shape.\n        tile_shape: size of the tiles.\n    \"\"\"\n    self.master = master\n    self.mosaic_shape = mosaic_shape\n    self.tile_shape = tile_shape\n    self.thresholds = []\n    self.origin = (\n        self.master.array.shape[0] % self.tile_shape[0] // 2,\n        self.master.array.shape[1] % self.tile_shape[1] // 2,\n    )\n    self._slices = None\n    self._arrays = None\n</code></pre>"},{"location":"reference/grid/#phomo.grid.Grid.plot","title":"<code>plot(colour=(255, 255, 255))</code>","text":"<p>Draw the tile edges on a copy of master image image.</p> <p>Parameters:</p> Name Type Description Default <code>colour</code> <code>Tuple[int, int, int]</code> <p>Colour of tile edges.</p> <code>(255, 255, 255)</code> <p>Returns:</p> Type Description <code>Image</code> <p>Master image with the tile grid overlayed ontop.</p> Source code in <code>phomo/grid.py</code> <pre><code>def plot(self, colour: Tuple[int, int, int] = (255, 255, 255)) -&gt; Image.Image:\n    \"\"\"Draw the tile edges on a copy of master image image.\n\n    Args:\n        colour: Colour of tile edges.\n\n    Returns:\n        Master image with the tile grid overlayed ontop.\n    \"\"\"\n    annotated_image = self.master.array.copy()\n    for y, x in self.slices:\n        annotated_image[y, x.start] = colour\n        annotated_image[y, x.stop - 1] = colour\n        annotated_image[y.start, x] = colour\n        annotated_image[y.stop - 1, x] = colour\n    return Image.fromarray(annotated_image)\n</code></pre>"},{"location":"reference/grid/#phomo.grid.Grid.remove_origin","title":"<code>remove_origin(slices)</code>","text":"<p>Remove the origin of the mosaic from a slice tuple.</p> Source code in <code>phomo/grid.py</code> <pre><code>def remove_origin(self, slices: Tuple[slice, slice]) -&gt; Tuple[slice, slice]:\n    \"\"\"Remove the origin of the mosaic from a slice tuple.\"\"\"\n    return (\n        slice(slices[0].start - self.origin[0], slices[0].stop - self.origin[0]),\n        slice(slices[1].start - self.origin[1], slices[1].stop - self.origin[1]),\n    )\n</code></pre>"},{"location":"reference/grid/#phomo.grid.Grid.subdivide","title":"<code>subdivide(threshold)</code>","text":"<p>Subdivide grid based on contrast.</p> Note <p>Modifies the grid in place.</p> <p>Parameters:</p> Name Type Description Default <code>threshold</code> <code>float</code> <p>contrast threshold at which to divide the slice into 4 smaller slices. Between 0 and 1.</p> required Source code in <code>phomo/grid.py</code> <pre><code>def subdivide(self, threshold: float) -&gt; None:\n    \"\"\"Subdivide grid based on contrast.\n\n    Note:\n        Modifies the grid in place.\n\n    Args:\n        threshold: contrast threshold at which to divide the slice into 4\n            smaller slices. Between 0 and 1.\n    \"\"\"\n    LOGGER.info(\"Subdividing with threshold %f\", threshold)\n    self._slices = list(self._yield_subdivide(threshold))\n    # clear the cached arrays\n    self._arrays = None\n    self.thresholds.append(threshold)\n</code></pre>"},{"location":"reference/master/","title":"master","text":""},{"location":"reference/master/#phomo.master.Master","title":"<code>Master</code>","text":"<p>               Bases: <code>Palette</code></p> Source code in <code>phomo/master.py</code> <pre><code>class Master(Palette):\n    @classmethod\n    def from_file(\n        cls,\n        master_image_file: PathLike,\n        crop_ratio: Optional[float] = None,\n        img_size: Optional[Tuple[int, int]] = None,\n        mode: Optional[str] = None,\n    ) -&gt; \"Master\":\n        \"\"\"Create a master image from file.\n\n        Args:\n            master_image_file: path to image file.\n            crop_ratio: width to height ratio to crop the master image to. 1 results in a square image.\n            img_size: resize the image to the provided size, width followed by height.\n            mode: convert the image to the provided mode. See PIL Modes.\n\n        Returns:\n            Master image instance.\n\n        Examples:\n            For black and white square 1280x1280 image.\n\n            &gt;&gt;&gt; Master.from_file(\"master.png\", crop_ratio=1, img_size=(1280, 1280), convert=\"L\")\n        \"\"\"\n        img = open_img_file(\n            master_image_file, crop_ratio=crop_ratio, size=img_size, mode=mode\n        )\n        return cls.from_image(img)\n\n    @classmethod\n    def from_image(cls, master_image: Image.Image) -&gt; \"Master\":\n        \"\"\"Create a master image from PIL.Image.Image\n\n        Args:\n            master_image: `PIL.Image` instance.\n\n        Returns:\n            Master image instance.\n        \"\"\"\n        array = np.asarray(master_image)\n        # make sure the arrays have 3 channels even in black and white\n        if array.ndim == 2:\n            array = np.stack([array] * 3, -1)\n        return cls(array)\n\n    def __init__(self, array: np.ndarray) -&gt; None:\n        \"\"\"The master image.\n\n        Args:\n            array: numpy array of the image, should contain 3 channels.\n\n        Returns:\n            Master image instance.\n        \"\"\"\n        super().__init__(array)\n\n    @property\n    def img(self):\n        \"\"\"`PIL.Image` of the master image.\"\"\"\n        return Image.fromarray(self.array.round(0).astype(\"uint8\"), mode=\"RGB\")\n\n    @property\n    def pixels(self) -&gt; np.ndarray:\n        \"\"\"Array containing the 3-channel pixel values of the master image.\"\"\"\n        return self.array.reshape(-1, self.array.shape[-1])\n\n    def __repr__(self) -&gt; str:\n        return f\"\"\"{self.__class__.__module__}.{self.__class__.__name__} at {hex(id(self))}:\n    shape: {self.array.shape}\"\"\"\n</code></pre>"},{"location":"reference/master/#phomo.master.Master.img","title":"<code>img</code>  <code>property</code>","text":"<p><code>PIL.Image</code> of the master image.</p>"},{"location":"reference/master/#phomo.master.Master.pixels","title":"<code>pixels: np.ndarray</code>  <code>property</code>","text":"<p>Array containing the 3-channel pixel values of the master image.</p>"},{"location":"reference/master/#phomo.master.Master.__init__","title":"<code>__init__(array)</code>","text":"<p>The master image.</p> <p>Parameters:</p> Name Type Description Default <code>array</code> <code>ndarray</code> <p>numpy array of the image, should contain 3 channels.</p> required <p>Returns:</p> Type Description <code>None</code> <p>Master image instance.</p> Source code in <code>phomo/master.py</code> <pre><code>def __init__(self, array: np.ndarray) -&gt; None:\n    \"\"\"The master image.\n\n    Args:\n        array: numpy array of the image, should contain 3 channels.\n\n    Returns:\n        Master image instance.\n    \"\"\"\n    super().__init__(array)\n</code></pre>"},{"location":"reference/master/#phomo.master.Master.from_file","title":"<code>from_file(master_image_file, crop_ratio=None, img_size=None, mode=None)</code>  <code>classmethod</code>","text":"<p>Create a master image from file.</p> <p>Parameters:</p> Name Type Description Default <code>master_image_file</code> <code>PathLike</code> <p>path to image file.</p> required <code>crop_ratio</code> <code>Optional[float]</code> <p>width to height ratio to crop the master image to. 1 results in a square image.</p> <code>None</code> <code>img_size</code> <code>Optional[Tuple[int, int]]</code> <p>resize the image to the provided size, width followed by height.</p> <code>None</code> <code>mode</code> <code>Optional[str]</code> <p>convert the image to the provided mode. See PIL Modes.</p> <code>None</code> <p>Returns:</p> Type Description <code>Master</code> <p>Master image instance.</p> <p>Examples:</p> <p>For black and white square 1280x1280 image.</p> <pre><code>&gt;&gt;&gt; Master.from_file(\"master.png\", crop_ratio=1, img_size=(1280, 1280), convert=\"L\")\n</code></pre> Source code in <code>phomo/master.py</code> <pre><code>@classmethod\ndef from_file(\n    cls,\n    master_image_file: PathLike,\n    crop_ratio: Optional[float] = None,\n    img_size: Optional[Tuple[int, int]] = None,\n    mode: Optional[str] = None,\n) -&gt; \"Master\":\n    \"\"\"Create a master image from file.\n\n    Args:\n        master_image_file: path to image file.\n        crop_ratio: width to height ratio to crop the master image to. 1 results in a square image.\n        img_size: resize the image to the provided size, width followed by height.\n        mode: convert the image to the provided mode. See PIL Modes.\n\n    Returns:\n        Master image instance.\n\n    Examples:\n        For black and white square 1280x1280 image.\n\n        &gt;&gt;&gt; Master.from_file(\"master.png\", crop_ratio=1, img_size=(1280, 1280), convert=\"L\")\n    \"\"\"\n    img = open_img_file(\n        master_image_file, crop_ratio=crop_ratio, size=img_size, mode=mode\n    )\n    return cls.from_image(img)\n</code></pre>"},{"location":"reference/master/#phomo.master.Master.from_image","title":"<code>from_image(master_image)</code>  <code>classmethod</code>","text":"<p>Create a master image from PIL.Image.Image</p> <p>Parameters:</p> Name Type Description Default <code>master_image</code> <code>Image</code> <p><code>PIL.Image</code> instance.</p> required <p>Returns:</p> Type Description <code>Master</code> <p>Master image instance.</p> Source code in <code>phomo/master.py</code> <pre><code>@classmethod\ndef from_image(cls, master_image: Image.Image) -&gt; \"Master\":\n    \"\"\"Create a master image from PIL.Image.Image\n\n    Args:\n        master_image: `PIL.Image` instance.\n\n    Returns:\n        Master image instance.\n    \"\"\"\n    array = np.asarray(master_image)\n    # make sure the arrays have 3 channels even in black and white\n    if array.ndim == 2:\n        array = np.stack([array] * 3, -1)\n    return cls(array)\n</code></pre>"},{"location":"reference/metrics/","title":"metrics","text":""},{"location":"reference/metrics/#phomo.metrics.greyscale","title":"<code>greyscale(master_chunk, tile_arrays, **kwargs)</code>","text":"<p>Compute the greyscale distance.</p> <p>This metric ignores colours and compares greyscale values. Should provide better photomosaics when using few tiles images.</p> <p>Parameters:</p> Name Type Description Default <code>master_chunk</code> <code>ndarray</code> <p>array containing the RGB pixels with values between 0 and 255.</p> required <code>tile_arrays</code> <code>ndarray</code> <p>array tile pixel arrays, values between 0 and 255.</p> required <code>**kwargs</code> <p>passed to <code>np.linalg.norm</code>.</p> <code>{}</code> <p>Returns:</p> Type Description <code>ndarray</code> <p>Colour distance approximation between the master chunk and all the tiles arrays.</p> Source code in <code>phomo/metrics.py</code> <pre><code>@register_metric\ndef greyscale(\n    master_chunk: np.ndarray, tile_arrays: np.ndarray, **kwargs\n) -&gt; np.ndarray:\n    \"\"\"Compute the greyscale distance.\n\n    This metric ignores colours and compares greyscale values. Should provide better\n    photomosaics when using few tiles images.\n\n\n    Args:\n        master_chunk: array containing the RGB pixels with values between 0 and 255.\n        tile_arrays: array tile pixel arrays, values between 0 and 255.\n        **kwargs: passed to ``np.linalg.norm``.\n\n    Returns:\n        Colour distance approximation between the master chunk and all the tiles\n            arrays.\n    \"\"\"\n    delta = np.subtract(\n        master_chunk.sum(axis=-1), tile_arrays.sum(axis=-1), dtype=float\n    )\n    return np.linalg.norm(delta.reshape(delta.shape[0], -1), axis=-1, **kwargs)\n</code></pre>"},{"location":"reference/metrics/#phomo.metrics.luv_approx","title":"<code>luv_approx(master_chunk, tile_arrays, **kwargs)</code>","text":"<p>Distance metric using a LUV space approximation.</p> <p>This metric should provide more accurate colour matching.</p> Reference <p>https://www.compuphase.com/cmetric.htm</p> <p>Parameters:</p> Name Type Description Default <code>master_chunk</code> <code>ndarray</code> <p>array containing the RGB pixels with values between and 255.</p> required <code>tile_arrays</code> <code>ndarray</code> <p>array containing the RGB pixels with values between 0 and 255.</p> required <code>**kwargs</code> <p>passed to <code>np.linalg.norm</code>.</p> <code>{}</code> <p>Returns:</p> Type Description <code>ndarray</code> <p>Colour distance approximation between the master chunk and all the tiles arrays.</p> Source code in <code>phomo/metrics.py</code> <pre><code>@register_metric\ndef luv_approx(\n    master_chunk: np.ndarray, tile_arrays: np.ndarray, **kwargs\n) -&gt; np.ndarray:\n    \"\"\"Distance metric using a L*U*V space approximation.\n\n    This metric should provide more accurate colour matching.\n\n    Reference:\n        https://www.compuphase.com/cmetric.htm\n\n    Args:\n        master_chunk: array containing the RGB pixels with values between and 255.\n        tile_arrays: array containing the RGB pixels with values between 0 and 255.\n        **kwargs: passed to ``np.linalg.norm``.\n\n    Returns:\n        Colour distance approximation between the master chunk and all the tiles\n            arrays.\n    \"\"\"\n    r = (master_chunk[:, :, 0] + tile_arrays[:, :, :, 0]) // 2\n    r = r.astype(float)\n    d = np.subtract(master_chunk, tile_arrays, dtype=float)\n    return np.linalg.norm(\n        (\n            ((512 + r) * d[:, :, :, 0] ** 2)\n            + 1024 * d[:, :, :, 1] ** 2\n            + ((767 - r) * d[:, :, :, 2] ** 2)\n        ).reshape(d.shape[0], -1),\n        axis=-1,\n        **kwargs,\n    )\n</code></pre>"},{"location":"reference/metrics/#phomo.metrics.norm","title":"<code>norm(master_chunk, tile_arrays, **kwargs)</code>","text":"<p>Distance metric using <code>np.linalg.norm</code>.</p> <p>Quick distance metric in RGB space.</p> <p>Parameters:</p> Name Type Description Default <code>master_chunk</code> <code>ndarray</code> <p>array containing the RGB pixels with values between 0 and 255.</p> required <code>tile_arrays</code> <code>ndarray</code> <p>list of tile pixel arrays, values between 0 and 255.</p> required <code>**kwargs</code> <p>passed to <code>np.linalg.norm</code>.</p> <code>{}</code> <p>Returns:</p> Type Description <code>ndarray</code> <p>Colour distance approximation between the master chunk and all the tiles arrays.</p> Source code in <code>phomo/metrics.py</code> <pre><code>@register_metric\ndef norm(master_chunk: np.ndarray, tile_arrays: np.ndarray, **kwargs) -&gt; np.ndarray:\n    \"\"\"Distance metric using ``np.linalg.norm``.\n\n    Quick distance metric in RGB space.\n\n    Args:\n        master_chunk: array containing the RGB pixels with values between 0 and 255.\n        tile_arrays: list of tile pixel arrays, values between 0 and 255.\n        **kwargs: passed to ``np.linalg.norm``.\n\n    Returns:\n        Colour distance approximation between the master chunk and all the tiles\n            arrays.\n    \"\"\"\n    return np.linalg.norm(\n        np.subtract(master_chunk, tile_arrays, dtype=float).reshape(\n            tile_arrays.shape[0], -1, tile_arrays.shape[-1]\n        ),\n        axis=(1, 2),\n        **kwargs,\n    )\n</code></pre>"},{"location":"reference/mosaic/","title":"mosaic","text":""},{"location":"reference/mosaic/#phomo.mosaic.Mosaic","title":"<code>Mosaic</code>","text":"Source code in <code>phomo/mosaic.py</code> <pre><code>class Mosaic:\n    @classmethod\n    def from_file_and_dir(\n        cls,\n        master_file: PathLike,\n        tile_dir: PathLike,\n        *args,\n        master_crop_ratio: Optional[float] = None,\n        master_size: Optional[Tuple[int, int]] = None,\n        master_mode: Optional[str] = None,\n        tile_crop_ratio: Optional[float] = None,\n        tile_size: Optional[Tuple[int, int]] = None,\n        tile_mode: Optional[str] = None,\n        **kwargs,\n    ) -&gt; \"Mosaic\":\n        \"\"\"Construct a `Mosaic` from a master image file and a directory containing the file images.\n\n        Args:\n            master_file: The master image file.\n            tile_dir: the directory containing the tile images.\n\n        Returns:\n            A `Mosaic` to construct the `master_file` using the tile images in the `tile_dir`.\n        \"\"\"\n        master = Master.from_file(\n            master_file,\n            crop_ratio=master_crop_ratio,\n            img_size=master_size,\n            mode=master_mode,\n        )\n        pool = Pool.from_dir(\n            tile_dir, tile_size=tile_size, crop_ratio=tile_crop_ratio, mode=tile_mode\n        )\n        return cls(master, pool, *args, **kwargs)\n\n    def __init__(\n        self,\n        master: Master,\n        pool: Pool,\n        n_appearances: int = 1,\n    ) -&gt; None:\n        \"\"\"Construct a regular grid mosaic.\n\n        Note:\n            The Pool's tiles should all be the same size.\n\n        Args:\n            master: `Master` image to reconstruct.\n            pool: Tile image pool with which to reconstruct the `Master` image.\n            n_appearances: Number of times a tile can appear in the mosaic.\n\n        Examples:\n            Building a mosaic.\n\n            &gt;&gt;&gt; pool = Pool.from_dir(\"tiles\")\n            &gt;&gt;&gt; master = Master.from_file(\"master.png\")\n            &gt;&gt;&gt; mosaic = Mosaic(master, pool, n_appearances=1)\n            &gt;&gt;&gt; mosaic.build(mosaic.d_matrix())\n        \"\"\"\n        self.master = master\n        if len(set([array.size for array in pool.array])) != 1:\n            raise ValueError(\"Pool tiles sizes are not identical.\")\n        self.pool = pool\n        self.tile_shape = (self.pool.array[0].shape[0], self.pool.array[0].shape[1])\n        self.n_appearances = n_appearances\n        self.grid = Grid(self.master, (self.size[1], self.size[0]), self.tile_shape)\n\n    @property\n    def size(self) -&gt; Tuple[int, int]:\n        \"\"\"The size of the mosaic image.\n\n        It can be different from the master image size as an integer number of\n        tiles should fit within it.\n\n        Returns:\n            The width and height of the mosaic image.\n        \"\"\"\n        return (\n            self.master.array.shape[1]\n            - self.master.array.shape[1] % self.tile_shape[1],\n            self.master.array.shape[0]\n            - self.master.array.shape[0] % self.tile_shape[0],\n        )\n\n    @property\n    def n_leftover(self) -&gt; int:\n        \"\"\"The number of tiles which will be unused when building the mosaic.\"\"\"\n        return len(self.pool) * self.n_appearances - len(self.grid.slices)\n\n    def _d_matrix_worker(\n        self, array: np.ndarray, metric_func: MetricCallable, **kwargs\n    ) -&gt; np.ndarray:\n        \"\"\"Parallel worker. Computes one row of the distance matrix.\"\"\"\n        # if the tile grid was subdivided the master array can be smaller\n        # than the tiles, need to resize to match the shapes\n        if array.shape[:-1] != self.tile_shape:\n            # this isn't exact because we are upscalling the master array\n            # we should be shrinking all the tile arrays but that is slower\n            array = resize_array(array, (self.tile_shape[1], self.tile_shape[0]))\n        return metric_func(array, self.pool.array, **kwargs)\n\n    def d_matrix(\n        self,\n        workers: int = 1,\n        metric: Union[str, MetricCallable] = \"norm\",\n        **kwargs,\n    ) -&gt; np.ndarray:\n        \"\"\"Compute the distance matrix between all the master's tiles and the\n        pool tiles.\n\n        Args:\n            workers: The number of worker to use.\n            metric: The distance metric used for the distance matrix. Either\n                provide a string, for implemented metrics see ``phomo.metrics.METRICS``.\n                Or a callable, which should take two ``np.ndarray``s and return a float.\n            **kwargs: Passed to `metric`.\n\n        Returns:\n            Distance matrix, shape: (number of master arrays, number of tiles in the pool).\n        \"\"\"\n        if isinstance(metric, str):\n            if metric not in METRICS.keys():\n                raise KeyError(\n                    \"'%s' not in available metrics: %s\",\n                    metric,\n                    repr(list(METRICS.keys())),\n                )\n            LOGGER.info(\"Using metric '%s'\", metric)\n            metric_func = METRICS[metric]\n        else:\n            LOGGER.info(\"Using user provided distance metric function.\")\n            metric_func = metric\n\n        # Compute the distance matrix.\n        worker = partial(self._d_matrix_worker, metric_func=metric_func, **kwargs)\n        if workers != 1:\n            LOGGER.info(\"Computing distance matrix with %i workers.\", workers)\n            with MpPool(processes=workers) as pool:\n                d_matrix = np.array(\n                    list(\n                        tqdm(\n                            pool.imap(\n                                worker,\n                                self.grid.arrays,\n                                chunksize=len(self.grid) // workers,\n                            ),\n                            total=len(self.grid.slices),\n                            desc=\"Building distance matrix\",\n                        )\n                    )\n                )\n        else:\n            # get rid of pool overhead if serial computation is desired.\n            LOGGER.info(\"Computing distance matrix in serial.\")\n            d_matrix = np.array(\n                [\n                    worker(array)\n                    for array in tqdm(self.grid.arrays, desc=\"Building distance matrix\")\n                ]\n            )\n        LOGGER.debug(\"d_matrix shape: %s\", d_matrix.shape)\n        return d_matrix\n\n    def d_matrix_cuda(self, metric: str = \"norm\") -&gt; np.ndarray:\n        \"\"\"Compute the distance matrix using CUDA for GPU acceleration.\n\n        Args:\n            metric: The distance metric used for the distance matrix. Either \"norm\" or \"greyscale\".\n\n        Returns:\n            Distance matrix, shape: (number of master arrays, number of tiles in the pool).\n        \"\"\"\n\n        try:\n            from numba import cuda\n        except ImportError:\n            raise ImportError(\n                \"Numba is required for CUDA support, run \\\"pip install 'phomo[cuda]'\\\" to install it.\"\n            )\n\n        if metric not in [\"norm\", \"greyscale\"]:\n            raise ValueError(\n                f\"Invalid metric '{metric}'. When using gpu `metric' must be 'norm' or 'greyscale'.\"\n            )\n\n        LOGGER.info(\"Computing distance matrix with CUDA.\")\n\n        # when the grid has been subdivided the master arrays will be smaller, so we grow them to match\n        # the tile size\n        grid_arrays = [\n            array\n            if array.shape == self.tile_shape\n            else resize_array(array, self.tile_shape)\n            for array in self.grid.arrays\n        ]\n        pool_arrays = self.pool.array\n        if metric == \"greyscale\":\n            grid_arrays = [array.sum(axis=-1, keepdims=True) for array in grid_arrays]\n            pool_arrays = [array.sum(axis=-1, keepdims=True) for array in pool_arrays]\n\n        # Transfer the master and pool arrays to the GPU.\n        master_arrays_device = cuda.to_device(grid_arrays)\n        pool_arrays_device = cuda.to_device(pool_arrays)\n\n        # Allocate memory for the distance matrix on the GPU.\n        d_matrix_device = cuda.device_array((len(grid_arrays), len(pool_arrays)))\n\n        # Define the CUDA kernel for computing the distance matrix.\n        @cuda.jit\n        def compute_d_matrix_kernel(master_arrays, pool_arrays, d_matrix):\n            i, j = cuda.grid(2)  # type: ignore\n            if i &lt; master_arrays.shape[0] and j &lt; pool_arrays.shape[0]:\n                distance = 0.0\n                for x in range(master_arrays.shape[1]):\n                    for y in range(master_arrays.shape[2]):\n                        for c in range(master_arrays.shape[3]):\n                            diff = master_arrays[i, x, y, c] - pool_arrays[j, x, y, c]\n                            distance += diff * diff\n                d_matrix[i, j] = math.sqrt(distance)\n\n        # Define the number of threads per block and blocks per grid.\n        threads_per_block = (16, 16)\n        blocks_per_grid_x = math.ceil(len(grid_arrays) / threads_per_block[0])\n        blocks_per_grid_y = math.ceil(len(pool_arrays) / threads_per_block[1])\n        blocks_per_grid = (blocks_per_grid_x, blocks_per_grid_y)\n\n        # Launch the kernel.\n        compute_d_matrix_kernel[blocks_per_grid, threads_per_block](  # type: ignore\n            master_arrays_device, pool_arrays_device, d_matrix_device\n        )\n\n        LOGGER.debug(\"d_matrix shape: %s\", d_matrix_device.shape)\n        # Copy the result back to the host.\n        return d_matrix_device.copy_to_host()\n\n    def build_greedy(self, d_matrix: np.ndarray) -&gt; Image.Image:\n        \"\"\"Construct the mosaic image using a greedy tile assignement algorithm.\n\n        This leads to less accurate mosaics, but is significantly faster than the\n        optimal assignement algorithm, especialy when the distance matrix is large.\n\n        Args:\n            d_matrix: The computed distance matrix.\n\n        Returns:\n            The `PIL.Image` instance of the mosaic.\n        \"\"\"\n        mosaic = np.zeros((self.size[1], self.size[0], 3))\n\n        # Keep track of tiles and sub arrays.\n        placed_master_arrays = set()\n        placed_tiles = set()\n        n_appearances = [0] * len(self.pool)\n\n        pbar = tqdm(total=d_matrix.shape[0], desc=\"Building mosaic\")\n        # from: https://stackoverflow.com/questions/29046162/numpy-array-loss-of-dimension-when-masking\n        sorted_master_slices_i, sorted_tiles = np.unravel_index(\n            np.argsort(d_matrix, axis=None), d_matrix.shape\n        )\n        for slices_i, tile in zip(sorted_master_slices_i, sorted_tiles):\n            if slices_i in placed_master_arrays or tile in placed_tiles:\n                continue\n            slices = self.grid.slices[slices_i]\n            tile_array = self.pool.array[tile]\n            # if the grid has been subdivided then the tile should be shrunk to\n            # the size of the subdivision\n            array_size = (\n                slices[1].stop - slices[1].start,\n                slices[0].stop - slices[0].start,\n            )\n            if tile_array.shape[:-1] != array_size[::-1]:\n                tile_array = resize_array(tile_array, array_size)\n\n            # shift slices back so that the centering of the mosaic within the\n            # master image is removed\n            slices = self.grid.remove_origin(slices)\n            mosaic[slices[0], slices[1]] = tile_array\n            placed_master_arrays.add(slices_i)\n            n_appearances[tile] += 1\n            if n_appearances[tile] == self.n_appearances:\n                placed_tiles.add(tile)\n            pbar.update(1)\n        pbar.close()\n        return Image.fromarray(np.uint8(mosaic))\n\n    def build(self, d_matrix: np.ndarray) -&gt; Image.Image:\n        \"\"\"Construct the mosaic image by solving the linear sum assignment problem.\n        See: https://en.wikipedia.org/wiki/Assignment_problem\n\n        Args:\n            d_matrix: The computed distance matrix.\n\n        Returns:\n            The `PIL.Image` instance of the mosaic.\n\n        Examples:\n            Building a mosaic.\n\n            &gt;&gt;&gt; mosaic.build(mosaic.d_matrix())\n\n            On a GPU.\n\n            &gt;&gt;&gt; mosaic.build(mosaic.d_matrix_cuda())\n        \"\"\"\n        mosaic = np.zeros((self.size[1], self.size[0], 3))\n\n        # expand the dmatrix to allow for repeated tiles\n        if self.n_appearances &gt; 0:\n            d_matrix = np.tile(d_matrix, self.n_appearances)\n\n        LOGGER.info(\"Computing optimal tile assignment.\")\n        row_ind, col_ind = linear_sum_assignment(d_matrix)\n        pbar = tqdm(total=d_matrix.shape[0], desc=\"Building mosaic\")\n        for row, col in zip(row_ind, col_ind):\n            slices = self.grid.slices[row]\n            tile_array = self.pool.array[col % len(self.pool.array)]\n            # if the grid has been subdivided then the tile should be shrunk to\n            # the size of the subdivision\n            array_size = (\n                slices[1].stop - slices[1].start,\n                slices[0].stop - slices[0].start,\n            )\n            if tile_array.shape[:-1] != array_size[::-1]:\n                tile_array = resize_array(tile_array, array_size)\n\n            # shift slices back so that the centering of the mosaic within the\n            # master image is removed\n            slices = self.grid.remove_origin(slices)\n            mosaic[slices[0], slices[1]] = tile_array\n            pbar.update(1)\n        pbar.close()\n\n        return Image.fromarray(np.uint8(mosaic))\n\n    def __repr__(self) -&gt; str:\n        # indent these guys\n        master = repr(self.master).replace(\"\\n\", \"\\n    \")\n        pool = repr(self.pool).replace(\"\\n\", \"\\n    \")\n        grid = repr(self.grid).replace(\"\\n\", \"\\n    \")\n        return f\"\"\"{self.__class__.__module__}.{self.__class__.__name__} at {hex(id(self))}:\n    n_appearances: {self.n_appearances}\n    mosaic size: {self.size}\n    tile shape: {self.tile_shape}\n    leftover tiles: {self.n_leftover}\n    {grid}\n    {master}\n    {pool}\"\"\"\n</code></pre>"},{"location":"reference/mosaic/#phomo.mosaic.Mosaic.n_leftover","title":"<code>n_leftover: int</code>  <code>property</code>","text":"<p>The number of tiles which will be unused when building the mosaic.</p>"},{"location":"reference/mosaic/#phomo.mosaic.Mosaic.size","title":"<code>size: Tuple[int, int]</code>  <code>property</code>","text":"<p>The size of the mosaic image.</p> <p>It can be different from the master image size as an integer number of tiles should fit within it.</p> <p>Returns:</p> Type Description <code>Tuple[int, int]</code> <p>The width and height of the mosaic image.</p>"},{"location":"reference/mosaic/#phomo.mosaic.Mosaic.__init__","title":"<code>__init__(master, pool, n_appearances=1)</code>","text":"<p>Construct a regular grid mosaic.</p> Note <p>The Pool's tiles should all be the same size.</p> <p>Parameters:</p> Name Type Description Default <code>master</code> <code>Master</code> <p><code>Master</code> image to reconstruct.</p> required <code>pool</code> <code>Pool</code> <p>Tile image pool with which to reconstruct the <code>Master</code> image.</p> required <code>n_appearances</code> <code>int</code> <p>Number of times a tile can appear in the mosaic.</p> <code>1</code> <p>Examples:</p> <p>Building a mosaic.</p> <pre><code>&gt;&gt;&gt; pool = Pool.from_dir(\"tiles\")\n&gt;&gt;&gt; master = Master.from_file(\"master.png\")\n&gt;&gt;&gt; mosaic = Mosaic(master, pool, n_appearances=1)\n&gt;&gt;&gt; mosaic.build(mosaic.d_matrix())\n</code></pre> Source code in <code>phomo/mosaic.py</code> <pre><code>def __init__(\n    self,\n    master: Master,\n    pool: Pool,\n    n_appearances: int = 1,\n) -&gt; None:\n    \"\"\"Construct a regular grid mosaic.\n\n    Note:\n        The Pool's tiles should all be the same size.\n\n    Args:\n        master: `Master` image to reconstruct.\n        pool: Tile image pool with which to reconstruct the `Master` image.\n        n_appearances: Number of times a tile can appear in the mosaic.\n\n    Examples:\n        Building a mosaic.\n\n        &gt;&gt;&gt; pool = Pool.from_dir(\"tiles\")\n        &gt;&gt;&gt; master = Master.from_file(\"master.png\")\n        &gt;&gt;&gt; mosaic = Mosaic(master, pool, n_appearances=1)\n        &gt;&gt;&gt; mosaic.build(mosaic.d_matrix())\n    \"\"\"\n    self.master = master\n    if len(set([array.size for array in pool.array])) != 1:\n        raise ValueError(\"Pool tiles sizes are not identical.\")\n    self.pool = pool\n    self.tile_shape = (self.pool.array[0].shape[0], self.pool.array[0].shape[1])\n    self.n_appearances = n_appearances\n    self.grid = Grid(self.master, (self.size[1], self.size[0]), self.tile_shape)\n</code></pre>"},{"location":"reference/mosaic/#phomo.mosaic.Mosaic.build","title":"<code>build(d_matrix)</code>","text":"<p>Construct the mosaic image by solving the linear sum assignment problem. See: https://en.wikipedia.org/wiki/Assignment_problem</p> <p>Parameters:</p> Name Type Description Default <code>d_matrix</code> <code>ndarray</code> <p>The computed distance matrix.</p> required <p>Returns:</p> Type Description <code>Image</code> <p>The <code>PIL.Image</code> instance of the mosaic.</p> <p>Examples:</p> <p>Building a mosaic.</p> <pre><code>&gt;&gt;&gt; mosaic.build(mosaic.d_matrix())\n</code></pre> <p>On a GPU.</p> <pre><code>&gt;&gt;&gt; mosaic.build(mosaic.d_matrix_cuda())\n</code></pre> Source code in <code>phomo/mosaic.py</code> <pre><code>def build(self, d_matrix: np.ndarray) -&gt; Image.Image:\n    \"\"\"Construct the mosaic image by solving the linear sum assignment problem.\n    See: https://en.wikipedia.org/wiki/Assignment_problem\n\n    Args:\n        d_matrix: The computed distance matrix.\n\n    Returns:\n        The `PIL.Image` instance of the mosaic.\n\n    Examples:\n        Building a mosaic.\n\n        &gt;&gt;&gt; mosaic.build(mosaic.d_matrix())\n\n        On a GPU.\n\n        &gt;&gt;&gt; mosaic.build(mosaic.d_matrix_cuda())\n    \"\"\"\n    mosaic = np.zeros((self.size[1], self.size[0], 3))\n\n    # expand the dmatrix to allow for repeated tiles\n    if self.n_appearances &gt; 0:\n        d_matrix = np.tile(d_matrix, self.n_appearances)\n\n    LOGGER.info(\"Computing optimal tile assignment.\")\n    row_ind, col_ind = linear_sum_assignment(d_matrix)\n    pbar = tqdm(total=d_matrix.shape[0], desc=\"Building mosaic\")\n    for row, col in zip(row_ind, col_ind):\n        slices = self.grid.slices[row]\n        tile_array = self.pool.array[col % len(self.pool.array)]\n        # if the grid has been subdivided then the tile should be shrunk to\n        # the size of the subdivision\n        array_size = (\n            slices[1].stop - slices[1].start,\n            slices[0].stop - slices[0].start,\n        )\n        if tile_array.shape[:-1] != array_size[::-1]:\n            tile_array = resize_array(tile_array, array_size)\n\n        # shift slices back so that the centering of the mosaic within the\n        # master image is removed\n        slices = self.grid.remove_origin(slices)\n        mosaic[slices[0], slices[1]] = tile_array\n        pbar.update(1)\n    pbar.close()\n\n    return Image.fromarray(np.uint8(mosaic))\n</code></pre>"},{"location":"reference/mosaic/#phomo.mosaic.Mosaic.build_greedy","title":"<code>build_greedy(d_matrix)</code>","text":"<p>Construct the mosaic image using a greedy tile assignement algorithm.</p> <p>This leads to less accurate mosaics, but is significantly faster than the optimal assignement algorithm, especialy when the distance matrix is large.</p> <p>Parameters:</p> Name Type Description Default <code>d_matrix</code> <code>ndarray</code> <p>The computed distance matrix.</p> required <p>Returns:</p> Type Description <code>Image</code> <p>The <code>PIL.Image</code> instance of the mosaic.</p> Source code in <code>phomo/mosaic.py</code> <pre><code>def build_greedy(self, d_matrix: np.ndarray) -&gt; Image.Image:\n    \"\"\"Construct the mosaic image using a greedy tile assignement algorithm.\n\n    This leads to less accurate mosaics, but is significantly faster than the\n    optimal assignement algorithm, especialy when the distance matrix is large.\n\n    Args:\n        d_matrix: The computed distance matrix.\n\n    Returns:\n        The `PIL.Image` instance of the mosaic.\n    \"\"\"\n    mosaic = np.zeros((self.size[1], self.size[0], 3))\n\n    # Keep track of tiles and sub arrays.\n    placed_master_arrays = set()\n    placed_tiles = set()\n    n_appearances = [0] * len(self.pool)\n\n    pbar = tqdm(total=d_matrix.shape[0], desc=\"Building mosaic\")\n    # from: https://stackoverflow.com/questions/29046162/numpy-array-loss-of-dimension-when-masking\n    sorted_master_slices_i, sorted_tiles = np.unravel_index(\n        np.argsort(d_matrix, axis=None), d_matrix.shape\n    )\n    for slices_i, tile in zip(sorted_master_slices_i, sorted_tiles):\n        if slices_i in placed_master_arrays or tile in placed_tiles:\n            continue\n        slices = self.grid.slices[slices_i]\n        tile_array = self.pool.array[tile]\n        # if the grid has been subdivided then the tile should be shrunk to\n        # the size of the subdivision\n        array_size = (\n            slices[1].stop - slices[1].start,\n            slices[0].stop - slices[0].start,\n        )\n        if tile_array.shape[:-1] != array_size[::-1]:\n            tile_array = resize_array(tile_array, array_size)\n\n        # shift slices back so that the centering of the mosaic within the\n        # master image is removed\n        slices = self.grid.remove_origin(slices)\n        mosaic[slices[0], slices[1]] = tile_array\n        placed_master_arrays.add(slices_i)\n        n_appearances[tile] += 1\n        if n_appearances[tile] == self.n_appearances:\n            placed_tiles.add(tile)\n        pbar.update(1)\n    pbar.close()\n    return Image.fromarray(np.uint8(mosaic))\n</code></pre>"},{"location":"reference/mosaic/#phomo.mosaic.Mosaic.d_matrix","title":"<code>d_matrix(workers=1, metric='norm', **kwargs)</code>","text":"<p>Compute the distance matrix between all the master's tiles and the pool tiles.</p> <p>Parameters:</p> Name Type Description Default <code>workers</code> <code>int</code> <p>The number of worker to use.</p> <code>1</code> <code>metric</code> <code>Union[str, MetricCallable]</code> <p>The distance metric used for the distance matrix. Either provide a string, for implemented metrics see <code>phomo.metrics.METRICS</code>. Or a callable, which should take two <code>np.ndarray</code>s and return a float.</p> <code>'norm'</code> <code>**kwargs</code> <p>Passed to <code>metric</code>.</p> <code>{}</code> <p>Returns:</p> Type Description <code>ndarray</code> <p>Distance matrix, shape: (number of master arrays, number of tiles in the pool).</p> Source code in <code>phomo/mosaic.py</code> <pre><code>def d_matrix(\n    self,\n    workers: int = 1,\n    metric: Union[str, MetricCallable] = \"norm\",\n    **kwargs,\n) -&gt; np.ndarray:\n    \"\"\"Compute the distance matrix between all the master's tiles and the\n    pool tiles.\n\n    Args:\n        workers: The number of worker to use.\n        metric: The distance metric used for the distance matrix. Either\n            provide a string, for implemented metrics see ``phomo.metrics.METRICS``.\n            Or a callable, which should take two ``np.ndarray``s and return a float.\n        **kwargs: Passed to `metric`.\n\n    Returns:\n        Distance matrix, shape: (number of master arrays, number of tiles in the pool).\n    \"\"\"\n    if isinstance(metric, str):\n        if metric not in METRICS.keys():\n            raise KeyError(\n                \"'%s' not in available metrics: %s\",\n                metric,\n                repr(list(METRICS.keys())),\n            )\n        LOGGER.info(\"Using metric '%s'\", metric)\n        metric_func = METRICS[metric]\n    else:\n        LOGGER.info(\"Using user provided distance metric function.\")\n        metric_func = metric\n\n    # Compute the distance matrix.\n    worker = partial(self._d_matrix_worker, metric_func=metric_func, **kwargs)\n    if workers != 1:\n        LOGGER.info(\"Computing distance matrix with %i workers.\", workers)\n        with MpPool(processes=workers) as pool:\n            d_matrix = np.array(\n                list(\n                    tqdm(\n                        pool.imap(\n                            worker,\n                            self.grid.arrays,\n                            chunksize=len(self.grid) // workers,\n                        ),\n                        total=len(self.grid.slices),\n                        desc=\"Building distance matrix\",\n                    )\n                )\n            )\n    else:\n        # get rid of pool overhead if serial computation is desired.\n        LOGGER.info(\"Computing distance matrix in serial.\")\n        d_matrix = np.array(\n            [\n                worker(array)\n                for array in tqdm(self.grid.arrays, desc=\"Building distance matrix\")\n            ]\n        )\n    LOGGER.debug(\"d_matrix shape: %s\", d_matrix.shape)\n    return d_matrix\n</code></pre>"},{"location":"reference/mosaic/#phomo.mosaic.Mosaic.d_matrix_cuda","title":"<code>d_matrix_cuda(metric='norm')</code>","text":"<p>Compute the distance matrix using CUDA for GPU acceleration.</p> <p>Parameters:</p> Name Type Description Default <code>metric</code> <code>str</code> <p>The distance metric used for the distance matrix. Either \"norm\" or \"greyscale\".</p> <code>'norm'</code> <p>Returns:</p> Type Description <code>ndarray</code> <p>Distance matrix, shape: (number of master arrays, number of tiles in the pool).</p> Source code in <code>phomo/mosaic.py</code> <pre><code>def d_matrix_cuda(self, metric: str = \"norm\") -&gt; np.ndarray:\n    \"\"\"Compute the distance matrix using CUDA for GPU acceleration.\n\n    Args:\n        metric: The distance metric used for the distance matrix. Either \"norm\" or \"greyscale\".\n\n    Returns:\n        Distance matrix, shape: (number of master arrays, number of tiles in the pool).\n    \"\"\"\n\n    try:\n        from numba import cuda\n    except ImportError:\n        raise ImportError(\n            \"Numba is required for CUDA support, run \\\"pip install 'phomo[cuda]'\\\" to install it.\"\n        )\n\n    if metric not in [\"norm\", \"greyscale\"]:\n        raise ValueError(\n            f\"Invalid metric '{metric}'. When using gpu `metric' must be 'norm' or 'greyscale'.\"\n        )\n\n    LOGGER.info(\"Computing distance matrix with CUDA.\")\n\n    # when the grid has been subdivided the master arrays will be smaller, so we grow them to match\n    # the tile size\n    grid_arrays = [\n        array\n        if array.shape == self.tile_shape\n        else resize_array(array, self.tile_shape)\n        for array in self.grid.arrays\n    ]\n    pool_arrays = self.pool.array\n    if metric == \"greyscale\":\n        grid_arrays = [array.sum(axis=-1, keepdims=True) for array in grid_arrays]\n        pool_arrays = [array.sum(axis=-1, keepdims=True) for array in pool_arrays]\n\n    # Transfer the master and pool arrays to the GPU.\n    master_arrays_device = cuda.to_device(grid_arrays)\n    pool_arrays_device = cuda.to_device(pool_arrays)\n\n    # Allocate memory for the distance matrix on the GPU.\n    d_matrix_device = cuda.device_array((len(grid_arrays), len(pool_arrays)))\n\n    # Define the CUDA kernel for computing the distance matrix.\n    @cuda.jit\n    def compute_d_matrix_kernel(master_arrays, pool_arrays, d_matrix):\n        i, j = cuda.grid(2)  # type: ignore\n        if i &lt; master_arrays.shape[0] and j &lt; pool_arrays.shape[0]:\n            distance = 0.0\n            for x in range(master_arrays.shape[1]):\n                for y in range(master_arrays.shape[2]):\n                    for c in range(master_arrays.shape[3]):\n                        diff = master_arrays[i, x, y, c] - pool_arrays[j, x, y, c]\n                        distance += diff * diff\n            d_matrix[i, j] = math.sqrt(distance)\n\n    # Define the number of threads per block and blocks per grid.\n    threads_per_block = (16, 16)\n    blocks_per_grid_x = math.ceil(len(grid_arrays) / threads_per_block[0])\n    blocks_per_grid_y = math.ceil(len(pool_arrays) / threads_per_block[1])\n    blocks_per_grid = (blocks_per_grid_x, blocks_per_grid_y)\n\n    # Launch the kernel.\n    compute_d_matrix_kernel[blocks_per_grid, threads_per_block](  # type: ignore\n        master_arrays_device, pool_arrays_device, d_matrix_device\n    )\n\n    LOGGER.debug(\"d_matrix shape: %s\", d_matrix_device.shape)\n    # Copy the result back to the host.\n    return d_matrix_device.copy_to_host()\n</code></pre>"},{"location":"reference/mosaic/#phomo.mosaic.Mosaic.from_file_and_dir","title":"<code>from_file_and_dir(master_file, tile_dir, *args, master_crop_ratio=None, master_size=None, master_mode=None, tile_crop_ratio=None, tile_size=None, tile_mode=None, **kwargs)</code>  <code>classmethod</code>","text":"<p>Construct a <code>Mosaic</code> from a master image file and a directory containing the file images.</p> <p>Parameters:</p> Name Type Description Default <code>master_file</code> <code>PathLike</code> <p>The master image file.</p> required <code>tile_dir</code> <code>PathLike</code> <p>the directory containing the tile images.</p> required <p>Returns:</p> Type Description <code>Mosaic</code> <p>A <code>Mosaic</code> to construct the <code>master_file</code> using the tile images in the <code>tile_dir</code>.</p> Source code in <code>phomo/mosaic.py</code> <pre><code>@classmethod\ndef from_file_and_dir(\n    cls,\n    master_file: PathLike,\n    tile_dir: PathLike,\n    *args,\n    master_crop_ratio: Optional[float] = None,\n    master_size: Optional[Tuple[int, int]] = None,\n    master_mode: Optional[str] = None,\n    tile_crop_ratio: Optional[float] = None,\n    tile_size: Optional[Tuple[int, int]] = None,\n    tile_mode: Optional[str] = None,\n    **kwargs,\n) -&gt; \"Mosaic\":\n    \"\"\"Construct a `Mosaic` from a master image file and a directory containing the file images.\n\n    Args:\n        master_file: The master image file.\n        tile_dir: the directory containing the tile images.\n\n    Returns:\n        A `Mosaic` to construct the `master_file` using the tile images in the `tile_dir`.\n    \"\"\"\n    master = Master.from_file(\n        master_file,\n        crop_ratio=master_crop_ratio,\n        img_size=master_size,\n        mode=master_mode,\n    )\n    pool = Pool.from_dir(\n        tile_dir, tile_size=tile_size, crop_ratio=tile_crop_ratio, mode=tile_mode\n    )\n    return cls(master, pool, *args, **kwargs)\n</code></pre>"},{"location":"reference/palette/","title":"palette","text":""},{"location":"reference/palette/#phomo.palette.Palette","title":"<code>Palette</code>","text":"<p>Colour palette methods.</p> Source code in <code>phomo/palette.py</code> <pre><code>class Palette:\n    \"\"\"Colour palette methods.\"\"\"\n\n    array: np.ndarray\n\n    def __init__(self, array: ArrayLike):\n        self.array = np.array(array)\n        self.plot = PalettePlotter(self)\n\n    @property\n    def pixels(self) -&gt; np.ndarray:\n        \"\"\"Returns flattened pixels from the array.\"\"\"\n        return self.array.reshape(-1, self.array.shape[-1])\n\n    def equalize(self):\n        \"\"\"Equalize the colour distribution using `cv2.equalizeHist`.\n\n        Returns:\n            A new `Palette` with equalized colour distribution.\n        \"\"\"\n        # the array of the pool is (n_tiles, height, width, 3)\n        # the array of the master is (height, width, 3)\n        # so we flatten until the colour channels\n        out_shape = self.array.shape\n        array = self.array.reshape(-1, 3)\n        matched_image = np.zeros_like(array)\n        for i in range(3):  # Assuming 3 channels (RGB)\n            matched_image[:, i] = cv2.equalizeHist(array[:, i]).squeeze()\n        return self.__class__(matched_image.reshape(out_shape))\n\n    def match(self, other: \"Palette\"):\n        \"\"\"Match the colour distribution of this object to the colour distribution of the\n        `other` using the Reinhard colour transfer algorithm.\n\n        See:\n            https://api.semanticscholar.org/CorpusID:14088925\n\n        Args:\n            The other `Palette` to match this `Palette`'s colour distribution to.\n\n        Returns:\n            A new `Palette` with it's colour distribution matched the `other` `Palette`.\n        \"\"\"\n        self_shape = self.array.shape\n        self_array = self.array.reshape(-1, self.array.shape[1], 3)\n        target_array = other.array.reshape(-1, other.array.shape[1], 3)\n\n        source_lab = cv2.cvtColor(self_array, cv2.COLOR_RGB2LAB)\n        target_lab = cv2.cvtColor(target_array, cv2.COLOR_RGB2LAB)\n\n        # Compute the mean and standard deviation of each channel\n        src_mean, src_std = cv2.meanStdDev(source_lab)\n        tgt_mean, tgt_std = cv2.meanStdDev(target_lab)\n\n        src_mean, src_std = src_mean.flatten(), src_std.flatten()\n        tgt_mean, tgt_std = tgt_mean.flatten(), tgt_std.flatten()\n\n        epsilon = 1e-5\n        src_std = np.where(src_std &lt; epsilon, epsilon, src_std)\n\n        # Transfer color\n        result_lab = source_lab.astype(float)\n        for i in range(3):\n            result_lab[:, :, i] -= src_mean[i]\n            result_lab[:, :, i] = result_lab[:, :, i] * (tgt_std[i] / src_std[i])\n            result_lab[:, :, i] += tgt_mean[i]\n\n        # Clip values to valid range and convert back to uint8\n        result_lab = np.clip(result_lab, 0, 255).astype(np.uint8)\n        result_rgb = cv2.cvtColor(result_lab, cv2.COLOR_LAB2RGB)\n        return self.__class__(result_rgb.reshape(self_shape))\n</code></pre>"},{"location":"reference/palette/#phomo.palette.Palette.pixels","title":"<code>pixels: np.ndarray</code>  <code>property</code>","text":"<p>Returns flattened pixels from the array.</p>"},{"location":"reference/palette/#phomo.palette.Palette.equalize","title":"<code>equalize()</code>","text":"<p>Equalize the colour distribution using <code>cv2.equalizeHist</code>.</p> <p>Returns:</p> Type Description <p>A new <code>Palette</code> with equalized colour distribution.</p> Source code in <code>phomo/palette.py</code> <pre><code>def equalize(self):\n    \"\"\"Equalize the colour distribution using `cv2.equalizeHist`.\n\n    Returns:\n        A new `Palette` with equalized colour distribution.\n    \"\"\"\n    # the array of the pool is (n_tiles, height, width, 3)\n    # the array of the master is (height, width, 3)\n    # so we flatten until the colour channels\n    out_shape = self.array.shape\n    array = self.array.reshape(-1, 3)\n    matched_image = np.zeros_like(array)\n    for i in range(3):  # Assuming 3 channels (RGB)\n        matched_image[:, i] = cv2.equalizeHist(array[:, i]).squeeze()\n    return self.__class__(matched_image.reshape(out_shape))\n</code></pre>"},{"location":"reference/palette/#phomo.palette.Palette.match","title":"<code>match(other)</code>","text":"<p>Match the colour distribution of this object to the colour distribution of the <code>other</code> using the Reinhard colour transfer algorithm.</p> See <p>https://api.semanticscholar.org/CorpusID:14088925</p> <p>Returns:</p> Type Description <p>A new <code>Palette</code> with it's colour distribution matched the <code>other</code> <code>Palette</code>.</p> Source code in <code>phomo/palette.py</code> <pre><code>def match(self, other: \"Palette\"):\n    \"\"\"Match the colour distribution of this object to the colour distribution of the\n    `other` using the Reinhard colour transfer algorithm.\n\n    See:\n        https://api.semanticscholar.org/CorpusID:14088925\n\n    Args:\n        The other `Palette` to match this `Palette`'s colour distribution to.\n\n    Returns:\n        A new `Palette` with it's colour distribution matched the `other` `Palette`.\n    \"\"\"\n    self_shape = self.array.shape\n    self_array = self.array.reshape(-1, self.array.shape[1], 3)\n    target_array = other.array.reshape(-1, other.array.shape[1], 3)\n\n    source_lab = cv2.cvtColor(self_array, cv2.COLOR_RGB2LAB)\n    target_lab = cv2.cvtColor(target_array, cv2.COLOR_RGB2LAB)\n\n    # Compute the mean and standard deviation of each channel\n    src_mean, src_std = cv2.meanStdDev(source_lab)\n    tgt_mean, tgt_std = cv2.meanStdDev(target_lab)\n\n    src_mean, src_std = src_mean.flatten(), src_std.flatten()\n    tgt_mean, tgt_std = tgt_mean.flatten(), tgt_std.flatten()\n\n    epsilon = 1e-5\n    src_std = np.where(src_std &lt; epsilon, epsilon, src_std)\n\n    # Transfer color\n    result_lab = source_lab.astype(float)\n    for i in range(3):\n        result_lab[:, :, i] -= src_mean[i]\n        result_lab[:, :, i] = result_lab[:, :, i] * (tgt_std[i] / src_std[i])\n        result_lab[:, :, i] += tgt_mean[i]\n\n    # Clip values to valid range and convert back to uint8\n    result_lab = np.clip(result_lab, 0, 255).astype(np.uint8)\n    result_rgb = cv2.cvtColor(result_lab, cv2.COLOR_LAB2RGB)\n    return self.__class__(result_rgb.reshape(self_shape))\n</code></pre>"},{"location":"reference/palette/#phomo.palette.PalettePlotter","title":"<code>PalettePlotter</code>","text":"Source code in <code>phomo/palette.py</code> <pre><code>class PalettePlotter:\n    def __init__(self, palette: Palette):\n        self._palette = palette\n\n    def _colour_hist(self, **kwargs) -&gt; Tuple[np.ndarray, np.ndarray]:\n        \"\"\"Compute the 1D colour distributions.\n\n        Args:\n            **kwargs: passed to `numpy.histogram`.\n\n        Returns:\n            Histogram edges and counts.\n        \"\"\"\n        bins = kwargs.pop(\"bins\", range(256))\n        values = []\n        bin_edges = []\n        for i in range(self._palette.pixels.shape[1]):\n            freqs, edges = np.histogram(self._palette.pixels[:, i], bins=bins, **kwargs)\n            bin_edges.append(edges)\n            values.append(freqs)\n        values = np.vstack(values).T\n        bin_edges = np.vstack(bin_edges).T\n        return bin_edges, values\n\n    def _colour_hist_3d(\n        self, bins: int = 256\n    ) -&gt; Tuple[Tuple[np.ndarray, ...], np.ndarray]:\n        \"\"\"Compute the 3D colour distribution.\"\"\"\n        hist, edges = np.histogramdd(\n            self._palette.pixels,\n            bins=bins,\n            range=[(0, 255), (0, 255), (0, 255)],\n        )\n        return edges, hist\n\n    def _colour_palette(self, depth: int = 3):\n        pixels = self._palette.array.reshape(-1, 3)\n\n        def split(pixels: np.ndarray, depth: int) -&gt; list[np.ndarray]:\n            if len(pixels) == 0 or depth == 0:\n                return [pixels]\n\n            ranges = np.ptp(pixels, axis=0)\n            axis = np.argmax(ranges)\n            median = np.median(pixels[:, axis])\n\n            left = pixels[pixels[:, axis] &lt;= median]\n            right = pixels[pixels[:, axis] &gt; median]\n\n            return split(left, depth - 1) + split(right, depth - 1)\n\n        quantized = split(pixels, depth)\n\n        palette = [np.mean(region, axis=0) for region in quantized if len(region) &gt; 0]\n        palette = np.array(palette, dtype=np.uint8)\n\n        return palette[::-1]\n\n    def palette(self, depth: int = 3) -&gt; Tuple[Figure, np.ndarray]:\n        \"\"\"Show the dominant colours of the palette using a median cut algorithm.\n\n        See:\n            https://en.wikipedia.org/wiki/Median_cut\n\n        Args:\n            depth: The number of splits to perform.\n\n        Returns:\n            `Figure` and `np.array` of `Axes`.\n        \"\"\"\n        palette = self._colour_palette(depth=depth)\n\n        square_size = 50\n        palette_ar = np.zeros(\n            (square_size, len(palette) * square_size, 3), dtype=\"uint8\"\n        )\n\n        for i, color in enumerate(palette):\n            palette_ar[:, i * square_size : (i + 1) * square_size, :] = color\n\n        fig, ax = plt.subplots(\n            1,\n            figsize=(5, 5 * len(palette)),\n            frameon=False,\n        )\n        ax.imshow(palette_ar, aspect=\"equal\")\n        ax.set_axis_off()\n        ax.margins(0, 0)\n        fig.tight_layout(pad=0)\n        return fig, ax\n\n    def distribution(self, log: bool = False) -&gt; Tuple[Figure, np.ndarray]:\n        \"\"\"Plot the colour distribution of each channel.\n\n        Args:\n            log: Plot y axis in log scale.\n\n        Returns:\n            `Figure` and `np.array` of `Axes`.\n        \"\"\"\n\n        bin_edges, values = self._colour_hist()\n        fig, axs = plt.subplots(3, figsize=(12, 6))\n        channels = [\"Red\", \"Green\", \"Blue\"]\n        for i, (ax, channel) in enumerate(zip(axs, channels)):\n            ax.bar(\n                bin_edges[:-1, i],\n                values[:, i],\n                width=np.diff(bin_edges[:, i]),\n                align=\"edge\",\n                color=channel,\n            )\n            if log:\n                ax.set_yscale(\"log\")\n            ax.set_title(channel)\n            ax.set_xlim(0, 255)\n        fig.tight_layout()\n        return fig, axs\n\n    def distribution_2d(self) -&gt; Tuple[Figure, np.ndarray]:\n        \"\"\"Plot 2D projections of the 3D colour distribution.\n\n        Returns:\n            `Figure` and `np.array` of `Axes`.\n        \"\"\"\n        _, hist = self._colour_hist_3d()\n        fig, axs = plt.subplots(1, 3, figsize=(12, 4))\n        axs = axs.ravel()\n\n        titles = [\"Red-Green\", \"Green-Blue\", \"Blue-Red\"]\n        for i, (ax, title) in enumerate(zip(axs, titles)):\n            i = (i + 2) % 3\n            proj = np.sum(hist, axis=i)\n            if i != 1:\n                proj = proj.T\n            ax.imshow(\n                proj,\n                origin=\"lower\",\n                extent=[0, 255, 0, 255],\n                aspect=\"auto\",\n                vmax=np.mean(proj) + 3 * np.std(proj),\n            )\n            ax.set_title(title)\n            ax.set_xlabel(title.split(\"-\")[0])\n            ax.set_ylabel(title.split(\"-\")[1])\n\n        fig.tight_layout()\n        return fig, axs\n\n    def __call__(self):\n        \"\"\"Plot all the plots.\"\"\"\n        self.palette()\n        self.distribution()\n        self.distribution_2d()\n</code></pre>"},{"location":"reference/palette/#phomo.palette.PalettePlotter.__call__","title":"<code>__call__()</code>","text":"<p>Plot all the plots.</p> Source code in <code>phomo/palette.py</code> <pre><code>def __call__(self):\n    \"\"\"Plot all the plots.\"\"\"\n    self.palette()\n    self.distribution()\n    self.distribution_2d()\n</code></pre>"},{"location":"reference/palette/#phomo.palette.PalettePlotter.distribution","title":"<code>distribution(log=False)</code>","text":"<p>Plot the colour distribution of each channel.</p> <p>Parameters:</p> Name Type Description Default <code>log</code> <code>bool</code> <p>Plot y axis in log scale.</p> <code>False</code> <p>Returns:</p> Type Description <code>Tuple[Figure, ndarray]</code> <p><code>Figure</code> and <code>np.array</code> of <code>Axes</code>.</p> Source code in <code>phomo/palette.py</code> <pre><code>def distribution(self, log: bool = False) -&gt; Tuple[Figure, np.ndarray]:\n    \"\"\"Plot the colour distribution of each channel.\n\n    Args:\n        log: Plot y axis in log scale.\n\n    Returns:\n        `Figure` and `np.array` of `Axes`.\n    \"\"\"\n\n    bin_edges, values = self._colour_hist()\n    fig, axs = plt.subplots(3, figsize=(12, 6))\n    channels = [\"Red\", \"Green\", \"Blue\"]\n    for i, (ax, channel) in enumerate(zip(axs, channels)):\n        ax.bar(\n            bin_edges[:-1, i],\n            values[:, i],\n            width=np.diff(bin_edges[:, i]),\n            align=\"edge\",\n            color=channel,\n        )\n        if log:\n            ax.set_yscale(\"log\")\n        ax.set_title(channel)\n        ax.set_xlim(0, 255)\n    fig.tight_layout()\n    return fig, axs\n</code></pre>"},{"location":"reference/palette/#phomo.palette.PalettePlotter.distribution_2d","title":"<code>distribution_2d()</code>","text":"<p>Plot 2D projections of the 3D colour distribution.</p> <p>Returns:</p> Type Description <code>Tuple[Figure, ndarray]</code> <p><code>Figure</code> and <code>np.array</code> of <code>Axes</code>.</p> Source code in <code>phomo/palette.py</code> <pre><code>def distribution_2d(self) -&gt; Tuple[Figure, np.ndarray]:\n    \"\"\"Plot 2D projections of the 3D colour distribution.\n\n    Returns:\n        `Figure` and `np.array` of `Axes`.\n    \"\"\"\n    _, hist = self._colour_hist_3d()\n    fig, axs = plt.subplots(1, 3, figsize=(12, 4))\n    axs = axs.ravel()\n\n    titles = [\"Red-Green\", \"Green-Blue\", \"Blue-Red\"]\n    for i, (ax, title) in enumerate(zip(axs, titles)):\n        i = (i + 2) % 3\n        proj = np.sum(hist, axis=i)\n        if i != 1:\n            proj = proj.T\n        ax.imshow(\n            proj,\n            origin=\"lower\",\n            extent=[0, 255, 0, 255],\n            aspect=\"auto\",\n            vmax=np.mean(proj) + 3 * np.std(proj),\n        )\n        ax.set_title(title)\n        ax.set_xlabel(title.split(\"-\")[0])\n        ax.set_ylabel(title.split(\"-\")[1])\n\n    fig.tight_layout()\n    return fig, axs\n</code></pre>"},{"location":"reference/palette/#phomo.palette.PalettePlotter.palette","title":"<code>palette(depth=3)</code>","text":"<p>Show the dominant colours of the palette using a median cut algorithm.</p> See <p>https://en.wikipedia.org/wiki/Median_cut</p> <p>Parameters:</p> Name Type Description Default <code>depth</code> <code>int</code> <p>The number of splits to perform.</p> <code>3</code> <p>Returns:</p> Type Description <code>Tuple[Figure, ndarray]</code> <p><code>Figure</code> and <code>np.array</code> of <code>Axes</code>.</p> Source code in <code>phomo/palette.py</code> <pre><code>def palette(self, depth: int = 3) -&gt; Tuple[Figure, np.ndarray]:\n    \"\"\"Show the dominant colours of the palette using a median cut algorithm.\n\n    See:\n        https://en.wikipedia.org/wiki/Median_cut\n\n    Args:\n        depth: The number of splits to perform.\n\n    Returns:\n        `Figure` and `np.array` of `Axes`.\n    \"\"\"\n    palette = self._colour_palette(depth=depth)\n\n    square_size = 50\n    palette_ar = np.zeros(\n        (square_size, len(palette) * square_size, 3), dtype=\"uint8\"\n    )\n\n    for i, color in enumerate(palette):\n        palette_ar[:, i * square_size : (i + 1) * square_size, :] = color\n\n    fig, ax = plt.subplots(\n        1,\n        figsize=(5, 5 * len(palette)),\n        frameon=False,\n    )\n    ax.imshow(palette_ar, aspect=\"equal\")\n    ax.set_axis_off()\n    ax.margins(0, 0)\n    fig.tight_layout(pad=0)\n    return fig, ax\n</code></pre>"},{"location":"reference/pool/","title":"pool","text":""},{"location":"reference/pool/#phomo.pool.Pool","title":"<code>Pool</code>","text":"<p>               Bases: <code>Palette</code></p> Source code in <code>phomo/pool.py</code> <pre><code>class Pool(Palette):\n    @classmethod\n    def from_dir(\n        cls,\n        tile_dir: PathLike,\n        crop_ratio: Optional[float] = None,\n        tile_size: Optional[Tuple[int, int]] = None,\n        mode: Optional[str] = None,\n    ) -&gt; \"Pool\":\n        \"\"\"Create a `Pool` instance from the images in a directory.\n\n        Args:\n            tile_dir: path to directory containing the images.\n            crop_ratio: width to height ratio to crop the tile images to. 1 results in a\n                square image.\n            tile_size: resize the image to the provided size, width followed by height.\n            mode: convert the images to the provided mode.\n                See [PIL Modes](https://pillow.readthedocs.io/en/stable/handbook/concepts.html#modes).\n        \"\"\"\n        if not isinstance(tile_dir, Path):\n            tile_dir = Path(tile_dir)\n        if not tile_dir.is_dir():\n            raise ValueError(f\"'{tile_dir}' is not a directory.\")\n        array = cls._load_files(\n            list(tile_dir.glob(\"*\")),\n            crop_ratio=crop_ratio,\n            size=tile_size,\n            mode=mode,\n        )\n        return cls(array)\n\n    @classmethod\n    def from_files(\n        cls,\n        files: Sequence[PathLike],\n        crop_ratio: Optional[float] = None,\n        tile_size: Optional[Tuple[int, int]] = None,\n        mode: Optional[str] = None,\n    ) -&gt; \"Pool\":\n        \"\"\"Create a `Pool` instance from a list of images.\n\n        Args:\n            files: list of paths to the tile images.\n            crop_ratio: width to height ratio to crop the master image to. 1 results in a square image.\n            tile_size: resize the image to the provided size, width followed by height.\n            mode: mode the image to the provided mode.\n                See [PIL Modes](https://pillow.readthedocs.io/en/stable/handbook/concepts.html#modes).\n        \"\"\"\n        array = cls._load_files(files, crop_ratio=crop_ratio, size=tile_size, mode=mode)\n        return cls(array)\n\n    def __init__(\n        self,\n        array: ArrayLike,\n    ) -&gt; None:\n        \"\"\"A `Pool` of tile images, to use in contructing the photo mosaic.\n\n        Args:\n            array: `Pool` image data array. Should be (n_tiles, height, width, 3)\n        \"\"\"\n        super().__init__(array)\n\n    @property\n    def tiles(self) -&gt; \"PoolTiles\":\n        \"\"\"Access the Pool's tile images.\n\n        Examples:\n            Show the first image in the pool.\n\n            &gt;&gt;&gt; pool.tiles[0].show()\n        \"\"\"\n        return PoolTiles(self.array)\n\n    @property\n    def pixels(self) -&gt; np.ndarray:\n        \"\"\"Array containing the 3-channel pixel values of all the images in the Pool.\"\"\"\n        return np.vstack([array.reshape(-1, array.shape[-1]) for array in self.array])\n\n    @staticmethod\n    def _load_files(files: Sequence[PathLike], **kwargs) -&gt; List[np.ndarray]:\n        arrays = []\n        for tile in tqdm(files, desc=\"Loading tiles\"):\n            img = open_img_file(tile, **kwargs)\n            array = np.asarray(img)\n            # make sure the arrays have 3 channels even in black and white\n            if array.ndim == 2:\n                array = np.stack([array] * 3, -1)\n            arrays.append(array)\n        return arrays\n\n    def __len__(self) -&gt; int:\n        return len(self.array)\n\n    def __repr__(self) -&gt; str:\n        return f\"\"\"{self.__class__.__module__}.{self.__class__.__name__} at {hex(id(self))}:\n    len: {self.__len__()}\"\"\"\n</code></pre>"},{"location":"reference/pool/#phomo.pool.Pool.pixels","title":"<code>pixels: np.ndarray</code>  <code>property</code>","text":"<p>Array containing the 3-channel pixel values of all the images in the Pool.</p>"},{"location":"reference/pool/#phomo.pool.Pool.tiles","title":"<code>tiles: PoolTiles</code>  <code>property</code>","text":"<p>Access the Pool's tile images.</p> <p>Examples:</p> <p>Show the first image in the pool.</p> <pre><code>&gt;&gt;&gt; pool.tiles[0].show()\n</code></pre>"},{"location":"reference/pool/#phomo.pool.Pool.__init__","title":"<code>__init__(array)</code>","text":"<p>A <code>Pool</code> of tile images, to use in contructing the photo mosaic.</p> <p>Parameters:</p> Name Type Description Default <code>array</code> <code>ArrayLike</code> <p><code>Pool</code> image data array. Should be (n_tiles, height, width, 3)</p> required Source code in <code>phomo/pool.py</code> <pre><code>def __init__(\n    self,\n    array: ArrayLike,\n) -&gt; None:\n    \"\"\"A `Pool` of tile images, to use in contructing the photo mosaic.\n\n    Args:\n        array: `Pool` image data array. Should be (n_tiles, height, width, 3)\n    \"\"\"\n    super().__init__(array)\n</code></pre>"},{"location":"reference/pool/#phomo.pool.Pool.from_dir","title":"<code>from_dir(tile_dir, crop_ratio=None, tile_size=None, mode=None)</code>  <code>classmethod</code>","text":"<p>Create a <code>Pool</code> instance from the images in a directory.</p> <p>Parameters:</p> Name Type Description Default <code>tile_dir</code> <code>PathLike</code> <p>path to directory containing the images.</p> required <code>crop_ratio</code> <code>Optional[float]</code> <p>width to height ratio to crop the tile images to. 1 results in a square image.</p> <code>None</code> <code>tile_size</code> <code>Optional[Tuple[int, int]]</code> <p>resize the image to the provided size, width followed by height.</p> <code>None</code> <code>mode</code> <code>Optional[str]</code> <p>convert the images to the provided mode. See PIL Modes.</p> <code>None</code> Source code in <code>phomo/pool.py</code> <pre><code>@classmethod\ndef from_dir(\n    cls,\n    tile_dir: PathLike,\n    crop_ratio: Optional[float] = None,\n    tile_size: Optional[Tuple[int, int]] = None,\n    mode: Optional[str] = None,\n) -&gt; \"Pool\":\n    \"\"\"Create a `Pool` instance from the images in a directory.\n\n    Args:\n        tile_dir: path to directory containing the images.\n        crop_ratio: width to height ratio to crop the tile images to. 1 results in a\n            square image.\n        tile_size: resize the image to the provided size, width followed by height.\n        mode: convert the images to the provided mode.\n            See [PIL Modes](https://pillow.readthedocs.io/en/stable/handbook/concepts.html#modes).\n    \"\"\"\n    if not isinstance(tile_dir, Path):\n        tile_dir = Path(tile_dir)\n    if not tile_dir.is_dir():\n        raise ValueError(f\"'{tile_dir}' is not a directory.\")\n    array = cls._load_files(\n        list(tile_dir.glob(\"*\")),\n        crop_ratio=crop_ratio,\n        size=tile_size,\n        mode=mode,\n    )\n    return cls(array)\n</code></pre>"},{"location":"reference/pool/#phomo.pool.Pool.from_files","title":"<code>from_files(files, crop_ratio=None, tile_size=None, mode=None)</code>  <code>classmethod</code>","text":"<p>Create a <code>Pool</code> instance from a list of images.</p> <p>Parameters:</p> Name Type Description Default <code>files</code> <code>Sequence[PathLike]</code> <p>list of paths to the tile images.</p> required <code>crop_ratio</code> <code>Optional[float]</code> <p>width to height ratio to crop the master image to. 1 results in a square image.</p> <code>None</code> <code>tile_size</code> <code>Optional[Tuple[int, int]]</code> <p>resize the image to the provided size, width followed by height.</p> <code>None</code> <code>mode</code> <code>Optional[str]</code> <p>mode the image to the provided mode. See PIL Modes.</p> <code>None</code> Source code in <code>phomo/pool.py</code> <pre><code>@classmethod\ndef from_files(\n    cls,\n    files: Sequence[PathLike],\n    crop_ratio: Optional[float] = None,\n    tile_size: Optional[Tuple[int, int]] = None,\n    mode: Optional[str] = None,\n) -&gt; \"Pool\":\n    \"\"\"Create a `Pool` instance from a list of images.\n\n    Args:\n        files: list of paths to the tile images.\n        crop_ratio: width to height ratio to crop the master image to. 1 results in a square image.\n        tile_size: resize the image to the provided size, width followed by height.\n        mode: mode the image to the provided mode.\n            See [PIL Modes](https://pillow.readthedocs.io/en/stable/handbook/concepts.html#modes).\n    \"\"\"\n    array = cls._load_files(files, crop_ratio=crop_ratio, size=tile_size, mode=mode)\n    return cls(array)\n</code></pre>"},{"location":"reference/pool/#phomo.pool.PoolTiles","title":"<code>PoolTiles</code>","text":"<p>Helper interface to access of <code>PIL.Image</code> instances of the tiles.</p> Source code in <code>phomo/pool.py</code> <pre><code>class PoolTiles:\n    \"\"\"Helper interface to access of `PIL.Image` instances of the tiles.\"\"\"\n\n    def __init__(self, array: np.ndarray) -&gt; None:\n        self._array = array\n\n    def __getitem__(self, index) -&gt; Image.Image:\n        return Image.fromarray(self._array[index].round(0).astype(\"uint8\"), mode=\"RGB\")\n</code></pre>"},{"location":"reference/utils/","title":"utils","text":""},{"location":"reference/utils/#phomo.utils.crop_to_ratio","title":"<code>crop_to_ratio(image, ratio=1)</code>","text":"<p>Reshapes an image to the specified ratio by cropping along the larger dimension.</p> <p>Parameters:</p> Name Type Description Default <code>image</code> <code>Image</code> <p>PIL.Image to crop.</p> required <code>ratio</code> <code>float</code> <p>width to height ratio to which to crop the image. Use 1 to obtain a square image.</p> <code>1</code> <p>Returns:</p> Type Description <code>Image</code> <p>Cropped PIL.Image.</p> Source code in <code>phomo/utils.py</code> <pre><code>def crop_to_ratio(image: Image.Image, ratio: float = 1) -&gt; Image.Image:\n    \"\"\"Reshapes an image to the specified ratio by cropping along the larger\n    dimension.\n\n    Args:\n        image: PIL.Image to crop.\n        ratio: width to height ratio to which to crop the image. Use 1 to obtain a\n            square image.\n\n    Returns:\n        Cropped PIL.Image.\n    \"\"\"\n\n    width, height = image.size\n\n    def crop_height(image, rx):\n        return image.crop(\n            (\n                0,\n                (rx / 2),\n                width,\n                height - (rx / 2),\n            )\n        )\n\n    def crop_width(image, rx):\n        return image.crop(\n            (\n                (rx / 2),\n                0,\n                width - (rx / 2),\n                height,\n            )\n        )\n\n    # Find the delta change.\n    rxheight = width / ratio - height\n    rxwidth = height * ratio - width\n\n    # Can only crop pixels, not add them.\n    if rxheight &lt; 0 and rxwidth &lt; 0:\n        # If both sides can be cropped to get what we want:\n        # Select the largest (because both are negative)\n        if rxheight &gt; rxwidth:\n            return crop_height(image, rxheight * -1)\n        else:\n            return crop_width(image, rxwidth * -1)\n\n    elif rxheight &lt; 0:\n        # Trim height to fit aspect ratio\n        return crop_height(image, rxheight * -1)\n\n    elif rxwidth &lt; 0:\n        # Trim width to fit aspect ratio\n        return crop_width(image, rxwidth * -1)\n\n    else:\n        # Can't do anything in this case\n        return image\n</code></pre>"},{"location":"reference/utils/#phomo.utils.open_img_file","title":"<code>open_img_file(img_file, crop_ratio=None, size=None, mode=None)</code>","text":"<p>Open an image file with some extra bells and whistles.</p> <p>Parameters:</p> Name Type Description Default <code>img_file</code> <code>PathLike</code> <p>path to the image.</p> required <code>crop_ratio</code> <code>Optional[float]</code> <p>width to height to which to crop the image.</p> <code>None</code> <code>size</code> <code>Optional[Tuple[int, int]]</code> <p>resize image.</p> <code>None</code> <code>mode</code> <code>Optional[str]</code> <p>convert the image to the provided mode. See PIL image modes.</p> <code>None</code> <p>Returns:</p> Type Description <code>Image</code> <p>Image instance.</p> Source code in <code>phomo/utils.py</code> <pre><code>def open_img_file(\n    img_file: PathLike,\n    crop_ratio: Optional[float] = None,\n    size: Optional[Tuple[int, int]] = None,\n    mode: Optional[str] = None,\n) -&gt; Image.Image:\n    \"\"\"Open an image file with some extra bells and whistles.\n\n    Args:\n        img_file: path to the image.\n        crop_ratio: width to height to which to crop the image.\n        size: resize image.\n        mode: convert the image to the provided mode. See PIL image modes.\n\n    Returns:\n        Image instance.\n    \"\"\"\n    with Image.open(img_file) as img:\n        img_t = exif_transpose(img)\n        img = img_t if img_t is not None else img\n        if crop_ratio is not None:\n            img = crop_to_ratio(img, crop_ratio)\n        if size is not None:\n            img = img.resize(size)\n        if mode is not None:\n            img = img.convert(mode)\n        else:\n            img = img.convert(\"RGB\")\n    return img\n</code></pre>"},{"location":"reference/utils/#phomo.utils.rainbow_of_squares","title":"<code>rainbow_of_squares(target_dir, size=(10, 10), r_range=range(0, 256, 15), g_range=range(0, 256, 15), b_range=range(0, 256, 15))</code>","text":"<p>Generate a bunch of solid-color tiles for experimentation and testing.</p> <p>Parameters:</p> Name Type Description Default <code>target_dir</code> <code>Path</code> <p>direcotry in which to place the rainbow tiles.</p> required <code>size</code> <code>Tuple[int, int]</code> <p>size of the images, width followed by height.</p> <code>(10, 10)</code> <code>r_range_params</code> <p>Passed to <code>range()</code> to stride through the red channel.</p> required <code>g_range_params</code> <p>Passed to <code>range()</code> to stride through the green channel.</p> required <code>b_range_params</code> <p>Passed to <code>range()</code> to stride through the blue channel.</p> required Source code in <code>phomo/utils.py</code> <pre><code>def rainbow_of_squares(\n    target_dir: Path,\n    size: Tuple[int, int] = (10, 10),\n    r_range: range = range(0, 256, 15),\n    g_range: range = range(0, 256, 15),\n    b_range: range = range(0, 256, 15),\n) -&gt; None:\n    \"\"\"Generate a bunch of solid-color tiles for experimentation and testing.\n\n    Args:\n        target_dir: direcotry in which to place the rainbow tiles.\n        size: size of the images, width followed by height.\n        r_range_params: Passed to ``range()`` to stride through the red channel.\n        g_range_params: Passed to ``range()`` to stride through the green channel.\n        b_range_params: Passed to ``range()`` to stride through the blue channel.\n    \"\"\"\n    target_dir.mkdir(exist_ok=True)\n    with tqdm(\n        total=len(r_range) + len(g_range) + len(b_range), desc=\"Generating color tiles\"\n    ) as pbar:\n        canvas = np.ones((*size[::-1], 3))\n        for r in r_range:\n            for g in g_range:\n                for b in b_range:\n                    img = (canvas * [r, g, b]).astype(np.uint8)\n                    filename = \"{:03d}-{:03d}-{:03d}.png\".format(r, g, b)\n                    img = Image.fromarray(img, mode=\"RGB\")\n                    img.save(target_dir / filename)\n                    pbar.update()\n</code></pre>"},{"location":"reference/utils/#phomo.utils.resize_array","title":"<code>resize_array(array, size, *args, **kwargs)</code>","text":"<p>Resize an array representing and image.</p> <p>Parameters:</p> Name Type Description Default <code>array</code> <code>ndarray</code> <p>array containing the images data.</p> required <code>size</code> <code>Tuple[int, int]</code> <p>desired size, width followed by height.</p> required <code>*args,</code> <code>**kwargs</code> <p>passed to <code>PIL.Image.resize</code>.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>Array containing the resized image data.</p> Source code in <code>phomo/utils.py</code> <pre><code>def resize_array(\n    array: np.ndarray, size: Tuple[int, int], *args, **kwargs\n) -&gt; np.ndarray:\n    \"\"\"Resize an array representing and image.\n\n    Args:\n        array: array containing the images data.\n        size: desired size, width followed by height.\n        *args, **kwargs: passed to `PIL.Image.resize`.\n\n    Returns:\n        Array containing the resized image data.\n    \"\"\"\n    return np.asarray(Image.fromarray(array).resize(size, *args, **kwargs))\n</code></pre>"},{"location":"usage/cli/","title":"Command Line Interface","text":""},{"location":"usage/cli/#basic-usage","title":"Basic Usage","text":"<p>To use the <code>phomo</code> CLI, open your terminal and type:</p> <pre><code>phomo &lt;master-image-path&gt; &lt;tile-directory-path&gt; [options]\n</code></pre>"},{"location":"usage/cli/#positional-arguements","title":"Positional Arguements","text":"<ul> <li><code>&lt;master-image-path&gt;</code>: Path to the master image we want to reconstruct as a photo mosaic.</li> <li><code>&lt;tile-directory-path&gt;</code>: Directory containing the tile images. The images in this directory will be used to reconstruct the master image. The more images, the better the mosaic.</li> </ul>"},{"location":"usage/cli/#options","title":"Options","text":"<ul> <li><code>-h, --help</code>: Show the help message and exit.</li> <li><code>-o OUTPUT, --output OUTPUT</code>: Specify the mosaic output path.</li> <li><code>-c MASTER_CROP_RATIO, --master-crop-ratio MASTER_CROP_RATIO</code>: Crop the master image to width/height ratio.</li> <li><code>-s MASTER_SIZE [MASTER_SIZE ...], --master-size MASTER_SIZE [MASTER_SIZE ...]</code>: Resize master image to width, height.</li> <li><code>-C TILE_CROP_RATIO, --tile-crop-ratio TILE_CROP_RATIO</code>: Crop the tile images to width/height ratio.</li> <li><code>-S TILE_SIZE [TILE_SIZE ...], --tile-size TILE_SIZE [TILE_SIZE ...]</code>: Resize tile images to width, height.</li> <li><code>-n N_APPEARANCES, --n-appearances N_APPEARANCES</code>: The number of times a tile can appear in the mosaic.</li> <li><code>-b, --black-and-white</code>: Convert master and tile images to black and white.</li> <li><code>-g, --show-grid</code>: Show the tile grid, don't build the mosaic.</li> <li><code>-d SUBDIVISIONS [SUBDIVISIONS ...], --subdivisions SUBDIVISIONS [SUBDIVISIONS ...]</code>: Grid subdivision thresholds.</li> <li><code>-G, --gpu</code>: Use GPU for distance matrix computation. Requires installing with <code>pip install 'phomo[cuda]'</code>.</li> <li><code>-m {greyscale,norm,luv_approx}, --metric {greyscale,norm,luv_approx}</code>: Distance metric.</li> <li><code>-j WORKERS, --workers WORKERS</code>: Number of workers use to run when computing the distance matrix.</li> <li><code>-e, --equalize</code>: Equalize the colour distributions to cover the full colour space.</li> <li><code>--match-master-to-tiles</code>: Match the master image's colour distribution with the tile image colours.</li> <li><code>--match-tiles-to-master</code>: Match the tile images' colour distribution with the master image colours.</li> <li><code>-v, --verbose</code>: Verbosity.</li> </ul>"},{"location":"usage/cli/#examples","title":"Examples","text":""},{"location":"usage/cli/#with-20x20-mosaic-tiles-and-each-tile-appearing-at-most-twice","title":"With 20x20 mosaic tiles and each tile appearing at most twice","text":"<pre><code>phomo master.jpg tiles/ -o mosaic.jpg -S 20 20 -n 2\n</code></pre>"},{"location":"usage/cli/#resize-master-image-to-1080x1080-and-use-10x10-tiles-with-the-greyscale-metric","title":"Resize master image to 1080x1080 and use 10x10 tiles with the greyscale metric","text":"<pre><code>phomo master.jpg tiles/ -o mosaic.jpg -s 1920 1080 -S 10 10 -m greyscale\n</code></pre>"},{"location":"usage/cli/#subdivide-tile-regions-with-high-contrast-and-run-on-the-gpu","title":"Subdivide tile regions with high contrast and run on the GPU","text":"<pre><code>phomo master.jpg tiles/ -o mosaic.jpg -S 40 40 -G -d 0.1 0.1\n</code></pre>"},{"location":"usage/python_package/faces/","title":"Example","text":"<p>Let's import the 3 main classes.</p> In\u00a0[1]: Copied! <pre>from phomo import Master, Pool, Mosaic\n</pre> from phomo import Master, Pool, Mosaic <pre>/home/lcoyle/.cache/pypoetry/virtualenvs/phomo-pX3Qwu7w-py3.12/lib/python3.12/site-packages/tqdm/auto.py:21: TqdmWarning: IProgress not found. Please update jupyter and ipywidgets. See https://ipywidgets.readthedocs.io/en/stable/user_install.html\n  from .autonotebook import tqdm as notebook_tqdm\n</pre> In\u00a0[2]: Copied! <pre>pool = Pool.from_dir(\"faces/\", crop_ratio=1, tile_size=(20, 20))\npool\n</pre> pool = Pool.from_dir(\"faces/\", crop_ratio=1, tile_size=(20, 20)) pool <pre>Loading tiles: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 9780/9780 [00:04&lt;00:00, 2102.21it/s]\n</pre> Out[2]: <pre>phomo.pool.Pool at 0x7fbf6e0436e0:\n    len: 9780</pre> In\u00a0[3]: Copied! <pre>from pathlib import Path\n\nmaster_file = list(Path(\"faces\").glob('*'))[1534]\n</pre> from pathlib import Path  master_file = list(Path(\"faces\").glob('*'))[1534] In\u00a0[4]: Copied! <pre>master = Master.from_file(master_file, img_size=(400, 400))\nmaster\n</pre> master = Master.from_file(master_file, img_size=(400, 400)) master Out[4]: <pre>phomo.master.Master at 0x7fbf6c91a6f0:\n    shape: (400, 400, 3)</pre> In\u00a0[5]: Copied! <pre>master.img\n</pre> master.img Out[5]: In\u00a0[6]: Copied! <pre>mosaic = Mosaic(master, pool)\nmosaic\n</pre> mosaic = Mosaic(master, pool) mosaic Out[6]: <pre>phomo.mosaic.Mosaic at 0x7fbf6e075af0:\n    n_appearances: 1\n    mosaic size: (400, 400)\n    tile shape: (20, 20)\n    leftover tiles: 9380\n    phomo.grid.Grid at 0x7fbf55529700:\n        origin: (0, 0)\n        len slices: 400\n        thresholds: []\n    phomo.master.Master at 0x7fbf6c91a6f0:\n        shape: (400, 400, 3)\n    phomo.pool.Pool at 0x7fbf6e0436e0:\n        len: 9780</pre> <p>Let's show the tile grid to see how things line up.</p> In\u00a0[7]: Copied! <pre>mosaic.grid.plot()\n</pre> mosaic.grid.plot() Out[7]: <p>If we want to get fancy we can subdivide tiles with more contrast. We'll get more detail in thoss tiles but have inconsistent tile size.</p> In\u00a0[8]: Copied! <pre>mosaic.grid.subdivide(0.1)\nmosaic.grid.plot()\n</pre> mosaic.grid.subdivide(0.1) mosaic.grid.plot() Out[8]: <p>Next we compute the distance matrix, which will be used to decide which tile goes where. This is the process which takes the longest.</p> In\u00a0[9]: Copied! <pre>d_matrix = mosaic.d_matrix()\n</pre> d_matrix = mosaic.d_matrix() <pre>Building distance matrix: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 493/493 [00:25&lt;00:00, 18.96it/s]\n</pre> <p>If you have a GPU and installed <code>phomo</code> with the <code>cuda</code> extra (<code>pip install 'phomo[cuda]'</code>), you can use GPU acceleration to compute the distance metric.</p> In\u00a0[10]: Copied! <pre># d_matrix = mosaic.d_matrix_cuda()\n</pre> # d_matrix = mosaic.d_matrix_cuda() <p>Now we give the distance matrix to the mosaic to build the mosaic.</p> In\u00a0[11]: Copied! <pre>mosiac_img = mosaic.build(d_matrix)\nmosiac_img\n</pre> mosiac_img = mosaic.build(d_matrix) mosiac_img <pre>Building mosaic: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 493/493 [00:00&lt;00:00, 95864.25it/s]\n</pre> Out[11]: <p>If we want, we can use <code>PIL</code> to blend the master with the mosaic to smooth out some of the jaggedness.</p> In\u00a0[12]: Copied! <pre>from PIL import Image\n\nImage.blend(mosiac_img, master.img, 0.3)\n</pre> from PIL import Image  Image.blend(mosiac_img, master.img, 0.3) Out[12]:"},{"location":"usage/python_package/faces/#example","title":"Example\u00b6","text":"<p>There are three main classes:</p> <ul> <li><code>Master</code>: which represents the master image.</li> <li><code>Pool</code>: which is the pool of tile images to use to reconstruct the <code>Master</code> image.</li> <li><code>Mosaic</code>: which is to construct the photo mosaic for a <code>Master</code> image and <code>Pool</code> tiles.</li> </ul> <p>We'll be using the <code>UTKFace</code> dataset which can be downloaded here. Extract it to the <code>faces/</code> folder.</p> <p>It contains 9780 200x200 images of faces.</p>"},{"location":"usage/python_package/faces/#pool","title":"Pool\u00b6","text":"<p>We initialize the pool from the <code>faces/</code> folder. We'll be using 20x20 square tiles.</p>"},{"location":"usage/python_package/faces/#master","title":"Master\u00b6","text":"<p>Let's take a random image from the <code>faces/</code> folder and use that as the master image. We also resize the master image from 200x200 to 400x400.</p>"},{"location":"usage/python_package/faces/#mosaic","title":"Mosaic\u00b6","text":"<p>We can create the <code>Mosaic</code> from the master image and the tile pool.</p>"},{"location":"usage/python_package/matching/","title":"Palette Matching","text":"In\u00a0[1]: Copied! <pre>from phomo import Pool, Master, Mosaic\nfrom phomo.utils import rainbow_of_squares\n</pre> from phomo import Pool, Master, Mosaic from phomo.utils import rainbow_of_squares <pre>WARNING: CPU random generator seem to be failing, disabling hardware random number generation\nWARNING: RDRND generated: 0xffffffff 0xffffffff 0xffffffff 0xffffffff\n/home/lcoyle/.cache/pypoetry/virtualenvs/phomo-pX3Qwu7w-py3.12/lib/python3.12/site-packages/tqdm/auto.py:21: TqdmWarning: IProgress not found. Please update jupyter and ipywidgets. See https://ipywidgets.readthedocs.io/en/stable/user_install.html\n  from .autonotebook import tqdm as notebook_tqdm\n</pre> In\u00a0[2]: Copied! <pre>import matplotlib.pyplot as plt\nimport numpy as np\n</pre> import matplotlib.pyplot as plt import numpy as np In\u00a0[3]: Copied! <pre>from pathlib import Path\n</pre> from pathlib import Path <p>We are once again using the <code>UTKFaces</code> dataset. As you would expect, is contains a lot of flesh tone colours.</p> In\u00a0[4]: Copied! <pre>pool = Pool.from_dir(\"faces/\", tile_size=(10, 10))\n</pre> pool = Pool.from_dir(\"faces/\", tile_size=(10, 10)) <pre>Loading tiles: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 9780/9780 [00:03&lt;00:00, 2478.07it/s]\n</pre> In\u00a0[5]: Copied! <pre>pool.plot()\n</pre> pool.plot() <p>As a master image let's use <code>Stary Night</code> which mostly has blues/greens.</p> <p>Due to the big difference in colour distribution between our master image and the tile images, we can't expect to get a great photo mosaic straight away.</p> In\u00a0[6]: Copied! <pre>master = Master.from_file(\"master.jpg\")\nmaster.img\n</pre> master = Master.from_file(\"master.jpg\") master.img Out[6]: In\u00a0[7]: Copied! <pre>master.plot()\n</pre> master.plot() In\u00a0[8]: Copied! <pre>def build_mosaic(master, pool):\n    mosaic = Mosaic(master, pool)\n    mosaic_img = mosaic.build(mosaic.d_matrix_cuda())\n    distance = np.linalg.norm(mosaic.master.array.astype(float) - np.array(mosaic_img).astype(float))\n    num_pixels = np.prod(mosaic.master.array.shape)\n    loss =  distance / num_pixels\n    print(f\"Loss: {loss}\")\n    return mosaic_img\n</pre> def build_mosaic(master, pool):     mosaic = Mosaic(master, pool)     mosaic_img = mosaic.build(mosaic.d_matrix_cuda())     distance = np.linalg.norm(mosaic.master.array.astype(float) - np.array(mosaic_img).astype(float))     num_pixels = np.prod(mosaic.master.array.shape)     loss =  distance / num_pixels     print(f\"Loss: {loss}\")     return mosaic_img <p>Let's see what the photo mosaic looks like:</p> In\u00a0[9]: Copied! <pre>build_mosaic(master, pool)\n</pre> build_mosaic(master, pool) <pre>Building mosaic: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 1911/1911 [00:00&lt;00:00, 324388.48it/s]</pre> <pre>Loss: 0.06740223794924285\n</pre> <pre>\n</pre> Out[9]: <p>Yeah not great, clearly the flesh tones don't really match well with the blue/green <code>Stary Night</code>.</p> <p>We have a few ways to get around this.</p> In\u00a0[10]: Copied! <pre>master_eq = master.equalize()\npool_eq = pool.equalize()\nmaster_eq.img\n</pre> master_eq = master.equalize() pool_eq = pool.equalize() master_eq.img Out[10]: In\u00a0[11]: Copied! <pre>pool_eq.plot();\n</pre> pool_eq.plot(); In\u00a0[12]: Copied! <pre>master_eq.plot();\n</pre> master_eq.plot(); In\u00a0[13]: Copied! <pre>build_mosaic(master_eq, pool_eq)\n</pre> build_mosaic(master_eq, pool_eq) <pre>Building mosaic: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 1911/1911 [00:00&lt;00:00, 385518.49it/s]</pre> <pre>Loss: 0.06615275570074403\n</pre> <pre>\n</pre> Out[13]: <p>This is already much better, but, seeing as we modified the colour distribution of both the <code>Master</code> and the <code>Pool</code>, neither the tile images or the master image are representative of the original images.</p> <p>This is made obvious, by the eerily white faces which make up the clouds of the night sky.</p> In\u00a0[14]: Copied! <pre>matched_master = master.match(pool)\nmatched_master.img\n</pre> matched_master = master.match(pool) matched_master.img Out[14]: In\u00a0[15]: Copied! <pre>matched_master.plot();\n</pre> matched_master.plot(); In\u00a0[16]: Copied! <pre>build_mosaic(matched_master, pool)\n</pre> build_mosaic(matched_master, pool) <pre>Building mosaic: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 1911/1911 [00:00&lt;00:00, 388226.05it/s]</pre> <pre>Loss: 0.04494942425162315\n</pre> <pre>\n</pre> Out[16]: <p>Ok so we get a nicer flesh toned <code>Stary Night</code>, where the tile images are the unmodified images we provided.</p> In\u00a0[17]: Copied! <pre>pool_matched = pool.match(master)\n</pre> pool_matched = pool.match(master) In\u00a0[18]: Copied! <pre>pool_matched.plot();\n</pre> pool_matched.plot(); In\u00a0[19]: Copied! <pre>build_mosaic(master, pool_matched)\n</pre> build_mosaic(master, pool_matched) <pre>Building mosaic: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 1911/1911 [00:00&lt;00:00, 375283.97it/s]</pre> <pre>Loss: 0.03631232331544263\n</pre> <pre>\n</pre> Out[19]: <p>This is the mosaic closest to the original <code>Stary Night</code>, but the tile images have been severly shifted towards the blue/green.</p>"},{"location":"usage/python_package/matching/#palette-matching","title":"Palette Matching\u00b6","text":""},{"location":"usage/python_package/matching/#equalizing-the-colour-distributions","title":"Equalizing the colour distributions\u00b6","text":"<p>We can spread the colour distributions of both the <code>Master</code> and the <code>Pool</code> to cover the full RGB space.</p> <p>This will modify the appearance of the master and pool images but lead to better mosaics.</p>"},{"location":"usage/python_package/matching/#palette-transfer","title":"Palette transfer\u00b6","text":""},{"location":"usage/python_package/matching/#master-pool","title":"<code>Master</code> -&gt; <code>Pool</code>\u00b6","text":"<p>Another approach is to cast the <code>Master</code>'s colour distribution to match the tile pool.</p> <p>This will modify the master image to be closer to the colours in the tile images while leaving the tile images unchanged.</p>"},{"location":"usage/python_package/matching/#pool-master","title":"<code>Pool</code> -&gt; <code>Master</code>\u00b6","text":"<p>We can also do the opposite, and modify the tile image pool to better match the master image.</p>"},{"location":"usage/python_package/metrics/","title":"Distance Matrix Metrics","text":"In\u00a0[1]: Copied! <pre>from phomo import METRICS\nfor metric, func in METRICS.items():\n    print(f\"{metric}: {func.__doc__}\\n\")\n</pre> from phomo import METRICS for metric, func in METRICS.items():     print(f\"{metric}: {func.__doc__}\\n\") <pre>greyscale: Compute the greyscale distance.\n\n    This metric ignores colours and compares greyscale values. Should provide better\n    photomosaics when using few tiles images.\n\n\n    Args:\n        master_chunk: array containing the RGB pixels with values between 0 and 255.\n        tile_arrays: array tile pixel arrays, values between 0 and 255.\n        **kwargs: passed to ``np.linalg.norm``.\n\n    Returns:\n        Colour distance approximation between the master chunk and all the tiles\n            arrays.\n    \n\nnorm: Distance metric using ``np.linalg.norm``.\n\n    Quick distance metric in RGB space.\n\n    Args:\n        master_chunk: array containing the RGB pixels with values between 0 and 255.\n        tile_arrays: list of tile pixel arrays, values between 0 and 255.\n        **kwargs: passed to ``np.linalg.norm``.\n\n    Returns:\n        Colour distance approximation between the master chunk and all the tiles\n            arrays.\n    \n\nluv_approx: Distance metric using a L*U*V space approximation.\n\n    This metric should provide more accurate colour matching.\n\n    Reference:\n        https://www.compuphase.com/cmetric.htm\n\n    Args:\n        master_chunk: array containing the RGB pixels with values between and 255.\n        tile_arrays: array containing the RGB pixels with values between 0 and 255.\n        **kwargs: passed to ``np.linalg.norm``.\n\n    Returns:\n        Colour distance approximation between the master chunk and all the tiles\n            arrays.\n    \n\n</pre> <pre>/home/lcoyle/.cache/pypoetry/virtualenvs/phomo-pX3Qwu7w-py3.12/lib/python3.12/site-packages/tqdm/auto.py:21: TqdmWarning: IProgress not found. Please update jupyter and ipywidgets. See https://ipywidgets.readthedocs.io/en/stable/user_install.html\n  from .autonotebook import tqdm as notebook_tqdm\n</pre> In\u00a0[2]: Copied! <pre>from phomo import Mosaic, Master, Pool\n</pre> from phomo import Mosaic, Master, Pool In\u00a0[3]: Copied! <pre>pool = Pool.from_dir(\"faces/\", crop_ratio=1, tile_size=(20, 20))\n</pre> pool = Pool.from_dir(\"faces/\", crop_ratio=1, tile_size=(20, 20)) <pre>Loading tiles: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 9780/9780 [00:04&lt;00:00, 2090.45it/s]\n</pre> In\u00a0[4]: Copied! <pre>from pathlib import Path\n\nmaster_file = list(Path(\"faces\").glob('*'))[3732]\n</pre> from pathlib import Path  master_file = list(Path(\"faces\").glob('*'))[3732] In\u00a0[5]: Copied! <pre>master = Master.from_file(master_file, img_size=(400, 400))\nmaster.img\n</pre> master = Master.from_file(master_file, img_size=(400, 400)) master.img Out[5]: In\u00a0[6]: Copied! <pre>mosaic = Mosaic(master, pool)\n</pre> mosaic = Mosaic(master, pool) In\u00a0[7]: Copied! <pre>mosaic.build(mosaic.d_matrix(metric=\"norm\"))\n</pre> mosaic.build(mosaic.d_matrix(metric=\"norm\")) <pre>Building distance matrix: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 400/400 [00:21&lt;00:00, 18.44it/s]\nBuilding mosaic: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 400/400 [00:00&lt;00:00, 101250.55it/s]\n</pre> Out[7]: In\u00a0[8]: Copied! <pre>mosaic.build(mosaic.d_matrix(metric=\"greyscale\"))\n</pre> mosaic.build(mosaic.d_matrix(metric=\"greyscale\")) <pre>Building distance matrix: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 400/400 [00:30&lt;00:00, 13.13it/s]\nBuilding mosaic: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 400/400 [00:00&lt;00:00, 249252.95it/s]\n</pre> Out[8]: In\u00a0[9]: Copied! <pre>mosaic.build(mosaic.d_matrix(metric=\"luv_approx\"))\n</pre> mosaic.build(mosaic.d_matrix(metric=\"luv_approx\")) <pre>Building distance matrix: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 400/400 [00:35&lt;00:00, 11.42it/s]\nBuilding mosaic: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 400/400 [00:00&lt;00:00, 164692.41it/s]\n</pre> Out[9]: In\u00a0[10]: Copied! <pre>mosaic.build(mosaic.d_matrix(metric=\"norm\", ord=1))\n</pre> mosaic.build(mosaic.d_matrix(metric=\"norm\", ord=1)) <pre>Building distance matrix: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 400/400 [00:34&lt;00:00, 11.55it/s]\nBuilding mosaic: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 400/400 [00:00&lt;00:00, 240430.15it/s]\n</pre> Out[10]: In\u00a0[11]: Copied! <pre>mosaic.build(mosaic.d_matrix(metric=\"norm\", ord=2))\n</pre> mosaic.build(mosaic.d_matrix(metric=\"norm\", ord=2)) <pre>Building distance matrix: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 400/400 [00:43&lt;00:00,  9.21it/s]\nBuilding mosaic: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 400/400 [00:00&lt;00:00, 254315.84it/s]\n</pre> Out[11]: In\u00a0[12]: Copied! <pre>mosaic.build(mosaic.d_matrix(metric=\"norm\", ord=\"fro\"))\n</pre> mosaic.build(mosaic.d_matrix(metric=\"norm\", ord=\"fro\")) <pre>Building distance matrix: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 400/400 [00:17&lt;00:00, 23.18it/s]\nBuilding mosaic: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 400/400 [00:00&lt;00:00, 203532.89it/s]\n</pre> Out[12]: In\u00a0[13]: Copied! <pre>mosaic.build(mosaic.d_matrix(metric=\"norm\", ord=\"nuc\"))\n</pre> mosaic.build(mosaic.d_matrix(metric=\"norm\", ord=\"nuc\")) <pre>Building distance matrix: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 400/400 [00:43&lt;00:00,  9.23it/s]\nBuilding mosaic: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 400/400 [00:00&lt;00:00, 236165.77it/s]\n</pre> Out[13]: In\u00a0[14]: Copied! <pre>mosaic.build(mosaic.d_matrix_cuda(metric=\"norm\"))\n</pre> mosaic.build(mosaic.d_matrix_cuda(metric=\"norm\")) <pre>Building mosaic: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 400/400 [00:00&lt;00:00, 180886.43it/s]\n</pre> Out[14]: In\u00a0[15]: Copied! <pre>mosaic.build(mosaic.d_matrix_cuda(metric=\"greyscale\"))\n</pre> mosaic.build(mosaic.d_matrix_cuda(metric=\"greyscale\")) <pre>Building mosaic: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 400/400 [00:00&lt;00:00, 264249.74it/s]\n</pre> Out[15]:"},{"location":"usage/python_package/metrics/#distance-matrix-metrics","title":"Distance Matrix Metrics\u00b6","text":"<p>There ara a few different distance metrics which can generate slightly different mosaics.</p>"},{"location":"usage/python_package/metrics/#all-the-different-metrics","title":"All the different metrics\u00b6","text":"<p>Let's go through the different distance metrics.</p>"},{"location":"usage/python_package/metrics/#changing-the-parameters-of-nplinalgnorm","title":"Changing the parameters of <code>np.linalg.norm</code>\u00b6","text":"<p>When using the <code>\"norm\"</code> we can also control the parameters of the <code>np.linalg.norm</code> function.</p> <p>This results in slightly different mosaics.</p> <p>See the numpy docs: https://numpy.org/doc/stable/reference/generated/numpy.linalg.norm.html</p>"},{"location":"usage/python_package/metrics/#gpu-metrics","title":"GPU metrics\u00b6","text":"<p>When using GPU acceleration through <code>Mosaic.d_matrix_cuda</code> only <code>\"norm\"</code> and <code>\"greyscale\"</code> are supported.</p>"},{"location":"usage/python_package/performance/","title":"Performance","text":"In\u00a0[1]: Copied! <pre>from phomo import Mosaic, Master, Pool\n</pre> from phomo import Mosaic, Master, Pool <pre>/home/lcoyle/.cache/pypoetry/virtualenvs/phomo-pX3Qwu7w-py3.12/lib/python3.12/site-packages/tqdm/auto.py:21: TqdmWarning: IProgress not found. Please update jupyter and ipywidgets. See https://ipywidgets.readthedocs.io/en/stable/user_install.html\n  from .autonotebook import tqdm as notebook_tqdm\n</pre> In\u00a0[2]: Copied! <pre>pool = Pool.from_dir(\"faces/\", crop_ratio=1, tile_size=(20, 20))\n</pre> pool = Pool.from_dir(\"faces/\", crop_ratio=1, tile_size=(20, 20)) <pre>Loading tiles: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 9780/9780 [00:04&lt;00:00, 2179.05it/s]\n</pre> In\u00a0[3]: Copied! <pre>from pathlib import Path\n\nmaster_file = list(Path(\"faces\").glob('*'))[5346]\n</pre> from pathlib import Path  master_file = list(Path(\"faces\").glob('*'))[5346] In\u00a0[4]: Copied! <pre>master = Master.from_file(master_file, img_size=(400, 400))\nmaster.img\n</pre> master = Master.from_file(master_file, img_size=(400, 400)) master.img Out[4]: In\u00a0[5]: Copied! <pre>mosaic = Mosaic(master, pool)\n</pre> mosaic = Mosaic(master, pool) In\u00a0[6]: Copied! <pre>%time mosaic.build(mosaic.d_matrix());\n</pre> %time mosaic.build(mosaic.d_matrix()); <pre>Building distance matrix: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 400/400 [00:16&lt;00:00, 23.79it/s]\nBuilding mosaic: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 400/400 [00:00&lt;00:00, 267323.39it/s]</pre> <pre>CPU times: user 9.56 s, sys: 7.5 s, total: 17.1 s\nWall time: 17.1 s\n</pre> <pre>\n</pre> In\u00a0[7]: Copied! <pre>%time mosaic.build(mosaic.d_matrix(workers=2));\n</pre> %time mosaic.build(mosaic.d_matrix(workers=2)); <pre>Building distance matrix: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 400/400 [00:10&lt;00:00, 38.31it/s]\nBuilding mosaic: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 400/400 [00:00&lt;00:00, 183437.74it/s]</pre> <pre>CPU times: user 346 ms, sys: 84.7 ms, total: 431 ms\nWall time: 10.8 s\n</pre> <pre>\n</pre> In\u00a0[8]: Copied! <pre>%time mosaic.build(mosaic.d_matrix(workers=4));\n</pre> %time mosaic.build(mosaic.d_matrix(workers=4)); <pre>Building distance matrix: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 400/400 [00:09&lt;00:00, 43.28it/s]\nBuilding mosaic: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 400/400 [00:00&lt;00:00, 222303.11it/s]</pre> <pre>CPU times: user 388 ms, sys: 92.3 ms, total: 480 ms\nWall time: 9.6 s\n</pre> <pre>\n</pre> In\u00a0[9]: Copied! <pre>%time mosaic.build(mosaic.d_matrix(workers=8));\n</pre> %time mosaic.build(mosaic.d_matrix(workers=8)); <pre>Building distance matrix: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 400/400 [00:09&lt;00:00, 41.25it/s]\nBuilding mosaic: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 400/400 [00:00&lt;00:00, 215922.99it/s]</pre> <pre>CPU times: user 503 ms, sys: 282 ms, total: 785 ms\nWall time: 10.1 s\n</pre> <pre>\n</pre> In\u00a0[10]: Copied! <pre>%time mosaic.build(mosaic.d_matrix(workers=16));\n</pre> %time mosaic.build(mosaic.d_matrix(workers=16)); <pre>Building distance matrix: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 400/400 [00:11&lt;00:00, 35.00it/s]\nBuilding mosaic: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 400/400 [00:00&lt;00:00, 158664.80it/s]</pre> <pre>CPU times: user 962 ms, sys: 540 ms, total: 1.5 s\nWall time: 12 s\n</pre> <pre>\n</pre> <p>On my system it seems using more that when going above 4 cores, the overhead slows downs the computation.</p> In\u00a0[11]: Copied! <pre>%timeit mosaic.build(mosaic.d_matrix_cuda());\n</pre> %timeit mosaic.build(mosaic.d_matrix_cuda()); <pre>Building mosaic: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 400/400 [00:00&lt;00:00, 157947.81it/s]\nBuilding mosaic: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 400/400 [00:00&lt;00:00, 154757.09it/s]\nBuilding mosaic: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 400/400 [00:00&lt;00:00, 163393.22it/s]\nBuilding mosaic: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 400/400 [00:00&lt;00:00, 166292.16it/s]\nBuilding mosaic: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 400/400 [00:00&lt;00:00, 164080.35it/s]\nBuilding mosaic: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 400/400 [00:00&lt;00:00, 168125.22it/s]\nBuilding mosaic: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 400/400 [00:00&lt;00:00, 159373.19it/s]\nBuilding mosaic: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 400/400 [00:00&lt;00:00, 162036.08it/s]</pre> <pre>512 ms \u00b1 16.2 ms per loop (mean \u00b1 std. dev. of 7 runs, 1 loop each)\n</pre> <pre>\n</pre> In\u00a0[14]: Copied! <pre>17.1 / 0.512\n</pre> 17.1 / 0.512 Out[14]: <pre>33.3984375</pre> <p>Running on GPU gives a ~30x performance increase compared to baseline.</p>"},{"location":"usage/python_package/performance/#performance","title":"Performance\u00b6","text":"<p>Here we'll look at the performance impact of using <code>multiprocessing</code> and GPU acceleration.</p>"},{"location":"usage/python_package/performance/#serial-computation","title":"Serial computation\u00b6","text":"<p>This is the baseline.</p>"},{"location":"usage/python_package/performance/#multiple-cores","title":"Multiple cores\u00b6","text":"<p>Let's use <code>multiprocessing</code> to parallelize over the CPU cores.</p> <p>Using multple cores somewhat breaks the tqdm progress bar.</p>"},{"location":"usage/python_package/performance/#running-on-gpu","title":"Running on GPU\u00b6","text":"<p>Now let's run  it on the GPU requires installing with <code>pip install 'phomo[cuda]'</code>. Here, on a <code>RTX 2060 SUPER</code>.</p>"},{"location":"usage/python_package/performance_trick/","title":"Performance trick","text":"In\u00a0[1]: Copied! <pre>from phomo import Master, Pool, Mosaic\n\nfrom PIL import Image\nfrom pathlib import Path\n</pre> from phomo import Master, Pool, Mosaic  from PIL import Image from pathlib import Path <pre>/home/lcoyle/.cache/pypoetry/virtualenvs/phomo-pX3Qwu7w-py3.12/lib/python3.12/site-packages/tqdm/auto.py:21: TqdmWarning: IProgress not found. Please update jupyter and ipywidgets. See https://ipywidgets.readthedocs.io/en/stable/user_install.html\n  from .autonotebook import tqdm as notebook_tqdm\n</pre> In\u00a0[2]: Copied! <pre>small_pool = Pool.from_dir(\"faces/\", crop_ratio=1, tile_size=(20, 20))\nlarge_pool = Pool.from_dir(\"faces/\", crop_ratio=1, tile_size=(200, 200))\n</pre> small_pool = Pool.from_dir(\"faces/\", crop_ratio=1, tile_size=(20, 20)) large_pool = Pool.from_dir(\"faces/\", crop_ratio=1, tile_size=(200, 200)) <pre>Loading tiles: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 9780/9780 [00:04&lt;00:00, 2174.39it/s]\nLoading tiles: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 9780/9780 [00:03&lt;00:00, 2932.25it/s]\n</pre> In\u00a0[3]: Copied! <pre>master_file = list(Path(\"faces\").glob('*'))[321]\n</pre> master_file = list(Path(\"faces\").glob('*'))[321] In\u00a0[4]: Copied! <pre>small_master = Master.from_file(master_file, img_size=(400, 400))\nlarge_master = Master.from_file(master_file, img_size=(4000, 4000))\n</pre> small_master = Master.from_file(master_file, img_size=(400, 400)) large_master = Master.from_file(master_file, img_size=(4000, 4000)) In\u00a0[5]: Copied! <pre>small_master.img\n</pre> small_master.img Out[5]: In\u00a0[6]: Copied! <pre>small_mosaic = Mosaic(small_master, small_pool)\nlarge_mosaic = Mosaic(large_master, large_pool)\n</pre> small_mosaic = Mosaic(small_master, small_pool) large_mosaic = Mosaic(large_master, large_pool) <p>We compute the distance matrix on the small mosaic.</p> In\u00a0[7]: Copied! <pre>d_matrix = small_mosaic.d_matrix()\n</pre> d_matrix = small_mosaic.d_matrix() <pre>Building distance matrix: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 400/400 [00:12&lt;00:00, 32.25it/s]\n</pre> <p>And give it to the large mosaic to build the mosaic. This way we get the performance of the small images and the resolution of the big mosaic. The downside is that by downsampling we do lose some accuracy when computing the distance matrix.</p> In\u00a0[8]: Copied! <pre>large_mosaic_img = large_mosaic.build(d_matrix=d_matrix)\n</pre> large_mosaic_img = large_mosaic.build(d_matrix=d_matrix) <pre>Building mosaic: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 400/400 [00:00&lt;00:00, 8016.56it/s]\n</pre> In\u00a0[9]: Copied! <pre>large_mosaic_img\n</pre> large_mosaic_img Out[9]:"},{"location":"usage/python_package/performance_trick/#performance-trick","title":"Performance trick\u00b6","text":"<p>For best performance use the <code>Mosaic.d_matrix_cuda</code> method to compute the distance matrix. It requires installing <code>phomo</code> with <code>pip install 'phomo[cuda]'</code>. If you do not have a GPU or it is incompatible with <code>cuda</code>, consider using this trick.</p> <p>The trick consist in computing the distance matrix on a smaller master/pool set but then building the mosaic image with higher resolution images.</p>"},{"location":"usage/python_package/performance_trick/#pools","title":"Pools\u00b6","text":"<p>We create a tile pool with small tiles (20x20) and one with big tiles (200x200).</p>"},{"location":"usage/python_package/performance_trick/#master-images","title":"Master images\u00b6","text":"<p>Same with the master image, one small (400x400) and one big (4000x4000).</p>"},{"location":"usage/python_package/performance_trick/#mosaics","title":"Mosaics\u00b6","text":"<p>Now the mosaics.</p>"}]}